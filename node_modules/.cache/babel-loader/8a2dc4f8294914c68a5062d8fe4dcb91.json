{"ast":null,"code":"function _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport React from \"react\";\nimport * as ReactIs from \"react-is\";\nimport mergeAllOf from \"json-schema-merge-allof\";\nimport fill from \"core-js-pure/features/array/fill\";\nimport union from \"lodash/union\";\nimport jsonpointer from \"jsonpointer\";\nimport fields from \"./components/fields\";\nimport widgets from \"./components/widgets\";\nimport validateFormData, { isValid } from \"./validate\";\nexport var ADDITIONAL_PROPERTY_FLAG = \"__additional_property\";\nvar widgetMap = {\n  \"boolean\": {\n    checkbox: \"CheckboxWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  string: {\n    text: \"TextWidget\",\n    password: \"PasswordWidget\",\n    email: \"EmailWidget\",\n    hostname: \"TextWidget\",\n    ipv4: \"TextWidget\",\n    ipv6: \"TextWidget\",\n    uri: \"URLWidget\",\n    \"data-url\": \"FileWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    textarea: \"TextareaWidget\",\n    hidden: \"HiddenWidget\",\n    date: \"DateWidget\",\n    datetime: \"DateTimeWidget\",\n    \"date-time\": \"DateTimeWidget\",\n    \"alt-date\": \"AltDateWidget\",\n    \"alt-datetime\": \"AltDateTimeWidget\",\n    color: \"ColorWidget\",\n    file: \"FileWidget\"\n  },\n  number: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  integer: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  array: {\n    select: \"SelectWidget\",\n    checkboxes: \"CheckboxesWidget\",\n    files: \"FileWidget\",\n    hidden: \"HiddenWidget\"\n  }\n};\nexport function canExpand(schema, uiSchema, formData) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n\n  var _getUiOptions = getUiOptions(uiSchema),\n      expandable = _getUiOptions.expandable;\n\n  if (expandable === false) {\n    return expandable;\n  } // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n\n\n  if (schema.maxProperties !== undefined) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n\n  return true;\n}\nexport function getDefaultRegistry() {\n  return {\n    fields: fields,\n    widgets: widgets,\n    definitions: {},\n    rootSchema: {},\n    formContext: {}\n  };\n}\n/* Gets the type of a given schema. */\n\nexport function getSchemaType(schema) {\n  var type = schema.type;\n\n  if (!type && schema[\"const\"]) {\n    return guessType(schema[\"const\"]);\n  }\n\n  if (!type && schema[\"enum\"]) {\n    return \"string\";\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return \"object\";\n  }\n\n  if (type instanceof Array && type.length === 2 && type.includes(\"null\")) {\n    return type.find(function (type) {\n      return type !== \"null\";\n    });\n  }\n\n  return type;\n}\nexport function getWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var type = getSchemaType(schema);\n\n  function mergeOptions(Widget) {\n    // cache return value as property of widget for proper react reconciliation\n    if (!Widget.MergedWidget) {\n      var defaultOptions = Widget.defaultProps && Widget.defaultProps.options || {};\n\n      Widget.MergedWidget = function (_ref) {\n        var _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            props = _objectWithoutProperties(_ref, [\"options\"]);\n\n        return React.createElement(Widget, _extends({\n          options: _objectSpread({}, defaultOptions, options)\n        }, props));\n      };\n    }\n\n    return Widget.MergedWidget;\n  }\n\n  if (typeof widget === \"function\" || ReactIs.isForwardRef(React.createElement(widget)) || ReactIs.isMemo(widget)) {\n    return mergeOptions(widget);\n  }\n\n  if (typeof widget !== \"string\") {\n    throw new Error(\"Unsupported widget definition: \".concat(_typeof(widget)));\n  }\n\n  if (registeredWidgets.hasOwnProperty(widget)) {\n    var registeredWidget = registeredWidgets[widget];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (!widgetMap.hasOwnProperty(type)) {\n    throw new Error(\"No widget for type \\\"\".concat(type, \"\\\"\"));\n  }\n\n  if (widgetMap[type].hasOwnProperty(widget)) {\n    var _registeredWidget = registeredWidgets[widgetMap[type][widget]];\n    return getWidget(schema, _registeredWidget, registeredWidgets);\n  }\n\n  throw new Error(\"No widget \\\"\".concat(widget, \"\\\" for type \\\"\").concat(type, \"\\\"\"));\n}\nexport function hasWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    if (e.message && (e.message.startsWith(\"No widget\") || e.message.startsWith(\"Unsupported widget\"))) {\n      return false;\n    }\n\n    throw e;\n  }\n}\n\nfunction computeDefaults(_schema, parentDefaults, rootSchema) {\n  var rawFormData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var includeUndefinedValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var schema = isObject(_schema) ? _schema : {};\n  var formData = isObject(rawFormData) ? rawFormData : {}; // Compute the defaults recursively: give highest priority to deepest nodes.\n\n  var defaults = parentDefaults;\n\n  if (isObject(defaults) && isObject(schema[\"default\"])) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults, schema[\"default\"]);\n  } else if (\"default\" in schema) {\n    // Use schema defaults for this node.\n    defaults = schema[\"default\"];\n  } else if (\"$ref\" in schema) {\n    // Use referenced schema defaults for this node.\n    var refSchema = findSchemaDefinition(schema.$ref, rootSchema);\n    return computeDefaults(refSchema, defaults, rootSchema, formData, includeUndefinedValues);\n  } else if (\"dependencies\" in schema) {\n    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return computeDefaults(resolvedSchema, defaults, rootSchema, formData, includeUndefinedValues);\n  } else if (isFixedItems(schema)) {\n    defaults = schema.items.map(function (itemSchema, idx) {\n      return computeDefaults(itemSchema, Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined, rootSchema, formData, includeUndefinedValues);\n    });\n  } else if (\"oneOf\" in schema) {\n    schema = schema.oneOf[getMatchingOption(undefined, schema.oneOf, rootSchema)];\n  } else if (\"anyOf\" in schema) {\n    schema = schema.anyOf[getMatchingOption(undefined, schema.anyOf, rootSchema)];\n  } // Not defaults defined for this node, fallback to generic typed ones.\n\n\n  if (typeof defaults === \"undefined\") {\n    defaults = schema[\"default\"];\n  }\n\n  switch (getSchemaType(schema)) {\n    // We need to recur for object schema inner default values.\n    case \"object\":\n      return Object.keys(schema.properties || {}).reduce(function (acc, key) {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        var computedDefault = computeDefaults(schema.properties[key], (defaults || {})[key], rootSchema, (formData || {})[key], includeUndefinedValues);\n\n        if (includeUndefinedValues || computedDefault !== undefined) {\n          acc[key] = computedDefault;\n        }\n\n        return acc;\n      }, {});\n\n    case \"array\":\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map(function (item, idx) {\n          return computeDefaults(schema.items[idx] || schema.additionalItems || {}, item, rootSchema);\n        });\n      } // Deeply inject defaults into already existing form data\n\n\n      if (Array.isArray(rawFormData)) {\n        defaults = rawFormData.map(function (item, idx) {\n          return computeDefaults(schema.items, (defaults || {})[idx], rootSchema, item);\n        });\n      }\n\n      if (schema.minItems) {\n        if (!isMultiSelect(schema, rootSchema)) {\n          var defaultsLength = defaults ? defaults.length : 0;\n\n          if (schema.minItems > defaultsLength) {\n            var defaultEntries = defaults || []; // populate the array with the defaults\n\n            var fillerSchema = Array.isArray(schema.items) ? schema.additionalItems : schema.items;\n            var fillerEntries = fill(new Array(schema.minItems - defaultsLength), computeDefaults(fillerSchema, fillerSchema.defaults, rootSchema)); // then fill up the rest with either the item default or empty, up to minItems\n\n            return defaultEntries.concat(fillerEntries);\n          }\n        } else {\n          return defaults ? defaults : [];\n        }\n      }\n\n  }\n\n  return defaults;\n}\n\nexport function getDefaultFormState(_schema, formData) {\n  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var includeUndefinedValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!isObject(_schema)) {\n    throw new Error(\"Invalid schema: \" + _schema);\n  }\n\n  var schema = retrieveSchema(_schema, rootSchema, formData);\n  var defaults = computeDefaults(schema, _schema[\"default\"], rootSchema, formData, includeUndefinedValues);\n\n  if (typeof formData === \"undefined\") {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n\n  if (isObject(formData) || Array.isArray(formData)) {\n    return mergeDefaultsWithFormData(defaults, formData);\n  }\n\n  if (formData === 0 || formData === false || formData === \"\") {\n    return formData;\n  }\n\n  return formData || defaults;\n}\n/**\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n */\n\nexport function mergeDefaultsWithFormData(defaults, formData) {\n  if (Array.isArray(formData)) {\n    if (!Array.isArray(defaults)) {\n      defaults = [];\n    }\n\n    return formData.map(function (value, idx) {\n      if (defaults[idx]) {\n        return mergeDefaultsWithFormData(defaults[idx], value);\n      }\n\n      return value;\n    });\n  } else if (isObject(formData)) {\n    var acc = Object.assign({}, defaults); // Prevent mutation of source object.\n\n    return Object.keys(formData).reduce(function (acc, key) {\n      acc[key] = mergeDefaultsWithFormData(defaults ? defaults[key] : {}, formData[key]);\n      return acc;\n    }, acc);\n  } else {\n    return formData;\n  }\n}\nexport function getUiOptions(uiSchema) {\n  // get all passed options from ui:widget, ui:options, and ui:<optionName>\n  return Object.keys(uiSchema).filter(function (key) {\n    return key.indexOf(\"ui:\") === 0;\n  }).reduce(function (options, key) {\n    var value = uiSchema[key];\n\n    if (key === \"ui:widget\" && isObject(value)) {\n      console.warn(\"Setting options via ui:widget object is deprecated, use ui:options instead\");\n      return _objectSpread({}, options, value.options || {}, {\n        widget: value.component\n      });\n    }\n\n    if (key === \"ui:options\" && isObject(value)) {\n      return _objectSpread({}, options, value);\n    }\n\n    return _objectSpread({}, options, _defineProperty({}, key.substring(3), value));\n  }, {});\n}\nexport function getDisplayLabel(schema, uiSchema, rootSchema) {\n  var uiOptions = getUiOptions(uiSchema);\n  var _uiOptions$label = uiOptions.label,\n      displayLabel = _uiOptions$label === void 0 ? true : _uiOptions$label;\n  var schemaType = getSchemaType(schema);\n\n  if (schemaType === \"array\") {\n    displayLabel = isMultiSelect(schema, rootSchema) || isFilesArray(schema, uiSchema, rootSchema);\n  }\n\n  if (schemaType === \"object\") {\n    displayLabel = false;\n  }\n\n  if (schemaType === \"boolean\" && !uiSchema[\"ui:widget\"]) {\n    displayLabel = false;\n  }\n\n  if (uiSchema[\"ui:field\"]) {\n    displayLabel = false;\n  }\n\n  return displayLabel;\n}\nexport function isObject(thing) {\n  if (typeof File !== \"undefined\" && thing instanceof File) {\n    return false;\n  }\n\n  return _typeof(thing) === \"object\" && thing !== null && !Array.isArray(thing);\n}\nexport function mergeObjects(obj1, obj2) {\n  var concatArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // Recursively merge deeply nested objects.\n\n  var acc = Object.assign({}, obj1); // Prevent mutation of source object.\n\n  return Object.keys(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      acc[key] = left.concat(right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\nexport function asNumber(value) {\n  if (value === \"\") {\n    return undefined;\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (/\\.$/.test(value)) {\n    // \"3.\" can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  var n = Number(value);\n  var valid = typeof n === \"number\" && !Number.isNaN(n);\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  return valid ? n : value;\n}\nexport function orderProperties(properties, order) {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  var arrayToHash = function arrayToHash(arr) {\n    return arr.reduce(function (prev, curr) {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  };\n\n  var errorPropList = function errorPropList(arr) {\n    return arr.length > 1 ? \"properties '\".concat(arr.join(\"', '\"), \"'\") : \"property '\".concat(arr[0], \"'\");\n  };\n\n  var propertyHash = arrayToHash(properties);\n  var orderFiltered = order.filter(function (prop) {\n    return prop === \"*\" || propertyHash[prop];\n  });\n  var orderHash = arrayToHash(orderFiltered);\n  var rest = properties.filter(function (prop) {\n    return !orderHash[prop];\n  });\n  var restIndex = orderFiltered.indexOf(\"*\");\n\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\"uiSchema order list does not contain \".concat(errorPropList(rest)));\n    }\n\n    return orderFiltered;\n  }\n\n  if (restIndex !== orderFiltered.lastIndexOf(\"*\")) {\n    throw new Error(\"uiSchema order list contains more than one wildcard item\");\n  }\n\n  var complete = _toConsumableArray(orderFiltered);\n\n  complete.splice.apply(complete, [restIndex, 1].concat(_toConsumableArray(rest)));\n  return complete;\n}\n/**\n * This function checks if the given schema matches a single\n * constant value.\n */\n\nexport function isConstant(schema) {\n  return Array.isArray(schema[\"enum\"]) && schema[\"enum\"].length === 1 || schema.hasOwnProperty(\"const\");\n}\nexport function toConstant(schema) {\n  if (Array.isArray(schema[\"enum\"]) && schema[\"enum\"].length === 1) {\n    return schema[\"enum\"][0];\n  } else if (schema.hasOwnProperty(\"const\")) {\n    return schema[\"const\"];\n  } else {\n    throw new Error(\"schema cannot be inferred as a constant\");\n  }\n}\nexport function isSelect(_schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var schema = retrieveSchema(_schema, rootSchema);\n  var altSchemas = schema.oneOf || schema.anyOf;\n\n  if (Array.isArray(schema[\"enum\"])) {\n    return true;\n  } else if (Array.isArray(altSchemas)) {\n    return altSchemas.every(function (altSchemas) {\n      return isConstant(altSchemas);\n    });\n  }\n\n  return false;\n}\nexport function isMultiSelect(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!schema.uniqueItems || !schema.items) {\n    return false;\n  }\n\n  return isSelect(schema.items, rootSchema);\n}\nexport function isFilesArray(schema, uiSchema) {\n  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (uiSchema[\"ui:widget\"] === \"files\") {\n    return true;\n  } else if (schema.items) {\n    var itemsSchema = retrieveSchema(schema.items, rootSchema);\n    return itemsSchema.type === \"string\" && itemsSchema.format === \"data-url\";\n  }\n\n  return false;\n}\nexport function isFixedItems(schema) {\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every(function (item) {\n    return isObject(item);\n  });\n}\nexport function allowAdditionalItems(schema) {\n  if (schema.additionalItems === true) {\n    console.warn(\"additionalItems=true is currently not supported\");\n  }\n\n  return isObject(schema.additionalItems);\n}\nexport function optionsList(schema) {\n  if (schema[\"enum\"]) {\n    return schema[\"enum\"].map(function (value, i) {\n      var label = schema.enumNames && schema.enumNames[i] || String(value);\n      return {\n        label: label,\n        value: value\n      };\n    });\n  } else {\n    var altSchemas = schema.oneOf || schema.anyOf;\n    return altSchemas.map(function (schema, i) {\n      var value = toConstant(schema);\n      var label = schema.title || String(value);\n      return {\n        schema: schema,\n        label: label,\n        value: value\n      };\n    });\n  }\n}\nexport function findSchemaDefinition($ref) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var origRef = $ref;\n\n  if ($ref.startsWith(\"#\")) {\n    // Decode URI fragment representation.\n    $ref = decodeURIComponent($ref.substring(1));\n  } else {\n    throw new Error(\"Could not find a definition for \".concat(origRef, \".\"));\n  }\n\n  var current = jsonpointer.get(rootSchema, $ref);\n\n  if (current === undefined) {\n    throw new Error(\"Could not find a definition for \".concat(origRef, \".\"));\n  }\n\n  if (current.hasOwnProperty(\"$ref\")) {\n    return findSchemaDefinition(current.$ref, rootSchema);\n  }\n\n  return current;\n} // In the case where we have to implicitly create a schema, it is useful to know what type to use\n//  based on the data we are defining\n\nexport var guessType = function guessType(value) {\n  if (Array.isArray(value)) {\n    return \"array\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (value == null) {\n    return \"null\";\n  } else if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (!isNaN(value)) {\n    return \"number\";\n  } else if (_typeof(value) === \"object\") {\n    return \"object\";\n  } // Default to string if we can't figure it out\n\n\n  return \"string\";\n}; // This function will create new \"properties\" items for each key in our formData\n\nexport function stubExistingAdditionalProperties(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // Clone the schema so we don't ruin the consumer's original\n\n  schema = _objectSpread({}, schema, {\n    properties: _objectSpread({}, schema.properties)\n  }); // make sure formData is an object\n\n  formData = isObject(formData) ? formData : {};\n  Object.keys(formData).forEach(function (key) {\n    if (schema.properties.hasOwnProperty(key)) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    var additionalProperties;\n\n    if (schema.additionalProperties.hasOwnProperty(\"$ref\")) {\n      additionalProperties = retrieveSchema({\n        $ref: schema.additionalProperties[\"$ref\"]\n      }, rootSchema, formData);\n    } else if (schema.additionalProperties.hasOwnProperty(\"type\")) {\n      additionalProperties = _objectSpread({}, schema.additionalProperties);\n    } else {\n      additionalProperties = {\n        type: guessType(formData[key])\n      };\n    } // The type of our new key should match the additionalProperties value;\n\n\n    schema.properties[key] = additionalProperties; // Set our additional property flag so we know it was dynamically added\n\n    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;\n  });\n  return schema;\n}\nexport function resolveSchema(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (schema.hasOwnProperty(\"$ref\")) {\n    return resolveReference(schema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"dependencies\")) {\n    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return retrieveSchema(resolvedSchema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"allOf\")) {\n    return _objectSpread({}, schema, {\n      allOf: schema.allOf.map(function (allOfSubschema) {\n        return retrieveSchema(allOfSubschema, rootSchema, formData);\n      })\n    });\n  } else {\n    // No $ref or dependencies attribute found, returning the original schema.\n    return schema;\n  }\n}\n\nfunction resolveReference(schema, rootSchema, formData) {\n  // Retrieve the referenced schema definition.\n  var $refSchema = findSchemaDefinition(schema.$ref, rootSchema); // Drop the $ref property of the source schema.\n\n  var $ref = schema.$ref,\n      localSchema = _objectWithoutProperties(schema, [\"$ref\"]); // Update referenced schema definition with local schema properties.\n\n\n  return retrieveSchema(_objectSpread({}, $refSchema, localSchema), rootSchema, formData);\n}\n\nexport function retrieveSchema(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!isObject(schema)) {\n    return {};\n  }\n\n  var resolvedSchema = resolveSchema(schema, rootSchema, formData);\n\n  if (\"allOf\" in schema) {\n    try {\n      resolvedSchema = mergeAllOf(_objectSpread({}, resolvedSchema, {\n        allOf: resolvedSchema.allOf\n      }));\n    } catch (e) {\n      console.warn(\"could not merge subschemas in allOf:\\n\" + e);\n\n      var _resolvedSchema = resolvedSchema,\n          allOf = _resolvedSchema.allOf,\n          resolvedSchemaWithoutAllOf = _objectWithoutProperties(_resolvedSchema, [\"allOf\"]);\n\n      return resolvedSchemaWithoutAllOf;\n    }\n  }\n\n  var hasAdditionalProperties = resolvedSchema.hasOwnProperty(\"additionalProperties\") && resolvedSchema.additionalProperties !== false;\n\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties(resolvedSchema, rootSchema, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction resolveDependencies(schema, rootSchema, formData) {\n  // Drop the dependencies from the source schema.\n  var _schema$dependencies = schema.dependencies,\n      dependencies = _schema$dependencies === void 0 ? {} : _schema$dependencies,\n      resolvedSchema = _objectWithoutProperties(schema, [\"dependencies\"]);\n\n  if (\"oneOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.oneOf[getMatchingOption(formData, resolvedSchema.oneOf, rootSchema)];\n  } else if (\"anyOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.anyOf[getMatchingOption(formData, resolvedSchema.anyOf, rootSchema)];\n  }\n\n  return processDependencies(dependencies, resolvedSchema, rootSchema, formData);\n}\n\nfunction processDependencies(dependencies, resolvedSchema, rootSchema, formData) {\n  // Process dependencies updating the local schema properties as appropriate.\n  for (var dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (formData[dependencyKey] === undefined) {\n      continue;\n    } // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n\n\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n\n    var dependencyValue = dependencies[dependencyKey],\n        remainingDependencies = _objectWithoutProperties(dependencies, [dependencyKey].map(_toPropertyKey));\n\n    if (Array.isArray(dependencyValue)) {\n      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      resolvedSchema = withDependentSchema(resolvedSchema, rootSchema, formData, dependencyKey, dependencyValue);\n    }\n\n    return processDependencies(remainingDependencies, resolvedSchema, rootSchema, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction withDependentProperties(schema, additionallyRequired) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n\n  var required = Array.isArray(schema.required) ? Array.from(new Set([].concat(_toConsumableArray(schema.required), _toConsumableArray(additionallyRequired)))) : additionallyRequired;\n  return _objectSpread({}, schema, {\n    required: required\n  });\n}\n\nfunction withDependentSchema(schema, rootSchema, formData, dependencyKey, dependencyValue) {\n  var _retrieveSchema = retrieveSchema(dependencyValue, rootSchema, formData),\n      oneOf = _retrieveSchema.oneOf,\n      dependentSchema = _objectWithoutProperties(_retrieveSchema, [\"oneOf\"]);\n\n  schema = mergeSchemas(schema, dependentSchema); // Since it does not contain oneOf, we return the original schema.\n\n  if (oneOf === undefined) {\n    return schema;\n  } else if (!Array.isArray(oneOf)) {\n    throw new Error(\"invalid: it is some \".concat(_typeof(oneOf), \" instead of an array\"));\n  } // Resolve $refs inside oneOf.\n\n\n  var resolvedOneOf = oneOf.map(function (subschema) {\n    return subschema.hasOwnProperty(\"$ref\") ? resolveReference(subschema, rootSchema, formData) : subschema;\n  });\n  return withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, resolvedOneOf);\n}\n\nfunction withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, oneOf) {\n  var validSubschemas = oneOf.filter(function (subschema) {\n    if (!subschema.properties) {\n      return false;\n    }\n\n    var conditionPropertySchema = subschema.properties[dependencyKey];\n\n    if (conditionPropertySchema) {\n      var conditionSchema = {\n        type: \"object\",\n        properties: _defineProperty({}, dependencyKey, conditionPropertySchema)\n      };\n\n      var _validateFormData = validateFormData(formData, conditionSchema),\n          errors = _validateFormData.errors;\n\n      return errors.length === 0;\n    }\n  });\n\n  if (validSubschemas.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return schema;\n  }\n\n  var subschema = validSubschemas[0];\n\n  var _subschema$properties = subschema.properties,\n      conditionPropertySchema = _subschema$properties[dependencyKey],\n      dependentSubschema = _objectWithoutProperties(_subschema$properties, [dependencyKey].map(_toPropertyKey));\n\n  var dependentSchema = _objectSpread({}, subschema, {\n    properties: dependentSubschema\n  });\n\n  return mergeSchemas(schema, retrieveSchema(dependentSchema, rootSchema, formData));\n} // Recursively merge deeply nested schemas.\n// The difference between mergeSchemas and mergeObjects\n// is that mergeSchemas only concats arrays for\n// values under the \"required\" keyword, and when it does,\n// it doesn't include duplicate values.\n\n\nexport function mergeSchemas(obj1, obj2) {\n  var acc = Object.assign({}, obj1); // Prevent mutation of source object.\n\n  return Object.keys(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (obj1 && obj2 && (getSchemaType(obj1) === \"object\" || getSchemaType(obj2) === \"object\") && key === \"required\" && Array.isArray(left) && Array.isArray(right)) {\n      // Don't include duplicate values when merging\n      // \"required\" fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === \"[object Arguments]\";\n}\n\nexport function deepEquals(a, b) {\n  var ca = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : []; // Partially extracted from node-deeper and adapted to exclude comparison\n  // checks for functions.\n  // https://github.com/othiym23/node-deeper\n\n  if (a === b) {\n    return true;\n  } else if (typeof a === \"function\" || typeof b === \"function\") {\n    // Assume all functions are equivalent\n    // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n    return true;\n  } else if (_typeof(a) !== \"object\" || _typeof(b) !== \"object\") {\n    return false;\n  } else if (a === null || b === null) {\n    return false;\n  } else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  } else if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;\n  } else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) {\n      return false;\n    }\n\n    var slice = Array.prototype.slice;\n    return deepEquals(slice.call(a), slice.call(b), ca, cb);\n  } else {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    var ka = Object.keys(a);\n    var kb = Object.keys(b); // don't bother with stack acrobatics if there's nothing there\n\n    if (ka.length === 0 && kb.length === 0) {\n      return true;\n    }\n\n    if (ka.length !== kb.length) {\n      return false;\n    }\n\n    var cal = ca.length;\n\n    while (cal--) {\n      if (ca[cal] === a) {\n        return cb[cal] === b;\n      }\n    }\n\n    ca.push(a);\n    cb.push(b);\n    ka.sort();\n    kb.sort();\n\n    for (var j = ka.length - 1; j >= 0; j--) {\n      if (ka[j] !== kb[j]) {\n        return false;\n      }\n    }\n\n    var _key;\n\n    for (var k = ka.length - 1; k >= 0; k--) {\n      _key = ka[k];\n\n      if (!deepEquals(a[_key], b[_key], ca, cb)) {\n        return false;\n      }\n    }\n\n    ca.pop();\n    cb.pop();\n    return true;\n  }\n}\nexport function shouldRender(comp, nextProps, nextState) {\n  var props = comp.props,\n      state = comp.state;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\nexport function toIdSchema(schema, id, rootSchema) {\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var idPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"root\";\n  var idSchema = {\n    $id: id || idPrefix\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    var _schema = retrieveSchema(schema, rootSchema, formData);\n\n    return toIdSchema(_schema, id, rootSchema, formData, idPrefix);\n  }\n\n  if (\"items\" in schema && !schema.items.$ref) {\n    return toIdSchema(schema.items, id, rootSchema, formData, idPrefix);\n  }\n\n  if (schema.type !== \"object\") {\n    return idSchema;\n  }\n\n  for (var name in schema.properties || {}) {\n    var field = schema.properties[name];\n    var fieldId = idSchema.$id + \"_\" + name;\n    idSchema[name] = toIdSchema(isObject(field) ? field : {}, fieldId, rootSchema, // It's possible that formData is not an object -- this can happen if an\n    // array item has just been added, but not populated with data yet\n    (formData || {})[name], idPrefix);\n  }\n\n  return idSchema;\n}\nexport function toPathSchema(schema) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var rootSchema = arguments.length > 2 ? arguments[2] : undefined;\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var pathSchema = {\n    $name: name.replace(/^\\./, \"\")\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    var _schema = retrieveSchema(schema, rootSchema, formData);\n\n    return toPathSchema(_schema, name, rootSchema, formData);\n  }\n\n  if (schema.hasOwnProperty(\"additionalProperties\")) {\n    pathSchema.__rjsf_additionalProperties = true;\n  }\n\n  if (schema.hasOwnProperty(\"items\") && Array.isArray(formData)) {\n    formData.forEach(function (element, i) {\n      pathSchema[i] = toPathSchema(schema.items, \"\".concat(name, \".\").concat(i), rootSchema, element);\n    });\n  } else if (schema.hasOwnProperty(\"properties\")) {\n    for (var property in schema.properties) {\n      pathSchema[property] = toPathSchema(schema.properties[property], \"\".concat(name, \".\").concat(property), rootSchema, // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      (formData || {})[property]);\n    }\n  }\n\n  return pathSchema;\n}\nexport function parseDateString(dateString) {\n  var includeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0\n    };\n  }\n\n  var date = new Date(dateString);\n\n  if (Number.isNaN(date.getTime())) {\n    throw new Error(\"Unable to parse date \" + dateString);\n  }\n\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1,\n    // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0\n  };\n}\nexport function toDateString(_ref2) {\n  var year = _ref2.year,\n      month = _ref2.month,\n      day = _ref2.day,\n      _ref2$hour = _ref2.hour,\n      hour = _ref2$hour === void 0 ? 0 : _ref2$hour,\n      _ref2$minute = _ref2.minute,\n      minute = _ref2$minute === void 0 ? 0 : _ref2$minute,\n      _ref2$second = _ref2.second,\n      second = _ref2$second === void 0 ? 0 : _ref2$second;\n  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  var datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\nexport function utcToLocal(jsonDate) {\n  if (!jsonDate) {\n    return \"\";\n  } // required format of `\"yyyy-MM-ddThh:mm\" followed by optional \":ss\" or \":ss.SSS\"\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n\n\n  var date = new Date(jsonDate);\n  var yyyy = pad(date.getFullYear(), 4);\n  var MM = pad(date.getMonth() + 1, 2);\n  var dd = pad(date.getDate(), 2);\n  var hh = pad(date.getHours(), 2);\n  var mm = pad(date.getMinutes(), 2);\n  var ss = pad(date.getSeconds(), 2);\n  var SSS = pad(date.getMilliseconds(), 3);\n  return \"\".concat(yyyy, \"-\").concat(MM, \"-\").concat(dd, \"T\").concat(hh, \":\").concat(mm, \":\").concat(ss, \".\").concat(SSS);\n}\nexport function localToUTC(dateString) {\n  if (dateString) {\n    return new Date(dateString).toJSON();\n  }\n}\nexport function pad(num, size) {\n  var s = String(num);\n\n  while (s.length < size) {\n    s = \"0\" + s;\n  }\n\n  return s;\n}\nexport function dataURItoBlob(dataURI) {\n  // Split metadata from data\n  var splitted = dataURI.split(\",\"); // Split params\n\n  var params = splitted[0].split(\";\"); // Get mime-type from params\n\n  var type = params[0].replace(\"data:\", \"\"); // Filter the name property from params\n\n  var properties = params.filter(function (param) {\n    return param.split(\"=\")[0] === \"name\";\n  }); // Look for the name and use unknown if no name property.\n\n  var name;\n\n  if (properties.length !== 1) {\n    name = \"unknown\";\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here.\n    name = properties[0].split(\"=\")[1];\n  } // Built the Uint8Array Blob parameter from the base64 string.\n\n\n  var binary = atob(splitted[1]);\n  var array = [];\n\n  for (var _i = 0; _i < binary.length; _i++) {\n    array.push(binary.charCodeAt(_i));\n  } // Create the blob object\n\n\n  var blob = new window.Blob([new Uint8Array(array)], {\n    type: type\n  });\n  return {\n    blob: blob,\n    name: name\n  };\n}\nexport function rangeSpec(schema) {\n  var spec = {};\n\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n\n  return spec;\n}\nexport function getMatchingOption(formData, options, rootSchema) {\n  for (var _i2 = 0; _i2 < options.length; _i2++) {\n    var option = options[_i2]; // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      var requiresAnyOf = {\n        anyOf: Object.keys(option.properties).map(function (key) {\n          return {\n            required: [key]\n          };\n        })\n      };\n      var augmentedSchema = void 0; // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        var shallowClone = _extends({}, option);\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      } // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n\n\n      delete augmentedSchema.required;\n\n      if (isValid(augmentedSchema, formData, rootSchema)) {\n        return _i2;\n      }\n    } else if (isValid(option, formData, rootSchema)) {\n      return _i2;\n    }\n  }\n\n  return 0;\n} // Check to see if a schema specifies that a value must be true\n\nexport function schemaRequiresTrueValue(schema) {\n  // Check if const is a truthy value\n  if (schema[\"const\"]) {\n    return true;\n  } // Check if an enum has a single value of true\n\n\n  if (schema[\"enum\"] && schema[\"enum\"].length === 1 && schema[\"enum\"][0] === true) {\n    return true;\n  } // If anyOf has a single value, evaluate the subschema\n\n\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0]);\n  } // If oneOf has a single value, evaluate the subschema\n\n\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0]);\n  } // Evaluate each subschema in allOf, to see if one of them requires a true\n  // value\n\n\n  if (schema.allOf) {\n    return schema.allOf.some(schemaRequiresTrueValue);\n  }\n\n  return false;\n}","map":{"version":3,"mappings":"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","names":["React","ReactIs","mergeAllOf","fill","union","jsonpointer","fields","widgets","validateFormData","isValid","ADDITIONAL_PROPERTY_FLAG","widgetMap","checkbox","radio","select","hidden","string","text","password","email","hostname","ipv4","ipv6","uri","textarea","date","datetime","color","file","number","updown","range","integer","array","checkboxes","files","canExpand","schema","uiSchema","formData","additionalProperties","getUiOptions","expandable","maxProperties","undefined","Object","keys","length","getDefaultRegistry","definitions","rootSchema","formContext","getSchemaType","type","guessType","properties","Array","includes","find","getWidget","widget","registeredWidgets","mergeOptions","Widget","MergedWidget","defaultOptions","defaultProps","options","props","isForwardRef","createElement","isMemo","Error","hasOwnProperty","registeredWidget","hasWidget","e","message","startsWith","computeDefaults","_schema","parentDefaults","rawFormData","includeUndefinedValues","isObject","defaults","mergeObjects","refSchema","findSchemaDefinition","$ref","resolvedSchema","resolveDependencies","isFixedItems","items","map","itemSchema","idx","isArray","oneOf","getMatchingOption","anyOf","reduce","acc","key","computedDefault","item","additionalItems","minItems","isMultiSelect","defaultsLength","defaultEntries","fillerSchema","fillerEntries","concat","getDefaultFormState","retrieveSchema","mergeDefaultsWithFormData","value","assign","filter","indexOf","console","warn","component","substring","getDisplayLabel","uiOptions","label","displayLabel","schemaType","isFilesArray","thing","File","_typeof","obj1","obj2","concatArrays","left","right","asNumber","test","n","Number","valid","isNaN","orderProperties","order","arrayToHash","arr","prev","curr","errorPropList","join","propertyHash","orderFiltered","prop","orderHash","rest","restIndex","lastIndexOf","complete","splice","isConstant","toConstant","isSelect","altSchemas","every","uniqueItems","itemsSchema","format","allowAdditionalItems","optionsList","i","enumNames","String","title","origRef","decodeURIComponent","current","get","stubExistingAdditionalProperties","forEach","resolveSchema","resolveReference","allOf","allOfSubschema","$refSchema","localSchema","resolvedSchemaWithoutAllOf","hasAdditionalProperties","dependencies","processDependencies","dependencyKey","dependencyValue","remainingDependencies","withDependentProperties","withDependentSchema","additionallyRequired","required","from","Set","dependentSchema","mergeSchemas","resolvedOneOf","subschema","withExactlyOneSubschema","validSubschemas","conditionPropertySchema","conditionSchema","errors","dependentSubschema","isArguments","object","prototype","toString","call","deepEquals","a","b","ca","cb","Date","getTime","RegExp","source","global","multiline","lastIndex","ignoreCase","slice","constructor","ka","kb","cal","push","sort","j","k","pop","shouldRender","comp","nextProps","nextState","state","toIdSchema","id","idPrefix","idSchema","$id","name","field","fieldId","toPathSchema","pathSchema","$name","replace","__rjsf_additionalProperties","element","property","parseDateString","dateString","includeTime","year","month","day","hour","minute","second","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","toDateString","time","utcTime","UTC","toJSON","utcToLocal","jsonDate","yyyy","pad","getFullYear","MM","getMonth","dd","getDate","hh","getHours","mm","getMinutes","ss","getSeconds","SSS","getMilliseconds","localToUTC","num","size","s","dataURItoBlob","dataURI","splitted","split","params","param","binary","atob","charCodeAt","blob","window","Blob","Uint8Array","rangeSpec","spec","multipleOf","step","minimum","min","maximum","max","option","requiresAnyOf","augmentedSchema","shallowClone","schemaRequiresTrueValue","some"],"sources":["/core/src/utils.js"],"sourcesContent":["import React from \"react\";\nimport * as ReactIs from \"react-is\";\nimport mergeAllOf from \"json-schema-merge-allof\";\nimport fill from \"core-js-pure/features/array/fill\";\nimport union from \"lodash/union\";\nimport jsonpointer from \"jsonpointer\";\nimport fields from \"./components/fields\";\nimport widgets from \"./components/widgets\";\nimport validateFormData, { isValid } from \"./validate\";\n\nexport const ADDITIONAL_PROPERTY_FLAG = \"__additional_property\";\n\nconst widgetMap = {\n  boolean: {\n    checkbox: \"CheckboxWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    hidden: \"HiddenWidget\",\n  },\n  string: {\n    text: \"TextWidget\",\n    password: \"PasswordWidget\",\n    email: \"EmailWidget\",\n    hostname: \"TextWidget\",\n    ipv4: \"TextWidget\",\n    ipv6: \"TextWidget\",\n    uri: \"URLWidget\",\n    \"data-url\": \"FileWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    textarea: \"TextareaWidget\",\n    hidden: \"HiddenWidget\",\n    date: \"DateWidget\",\n    datetime: \"DateTimeWidget\",\n    \"date-time\": \"DateTimeWidget\",\n    \"alt-date\": \"AltDateWidget\",\n    \"alt-datetime\": \"AltDateTimeWidget\",\n    color: \"ColorWidget\",\n    file: \"FileWidget\",\n  },\n  number: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\",\n  },\n  integer: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\",\n  },\n  array: {\n    select: \"SelectWidget\",\n    checkboxes: \"CheckboxesWidget\",\n    files: \"FileWidget\",\n    hidden: \"HiddenWidget\",\n  },\n};\n\nexport function canExpand(schema, uiSchema, formData) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n  const { expandable } = getUiOptions(uiSchema);\n  if (expandable === false) {\n    return expandable;\n  }\n  // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n  if (schema.maxProperties !== undefined) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n  return true;\n}\n\nexport function getDefaultRegistry() {\n  return {\n    fields,\n    widgets,\n    definitions: {},\n    rootSchema: {},\n    formContext: {},\n  };\n}\n\n/* Gets the type of a given schema. */\nexport function getSchemaType(schema) {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return \"string\";\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return \"object\";\n  }\n\n  if (type instanceof Array && type.length === 2 && type.includes(\"null\")) {\n    return type.find(type => type !== \"null\");\n  }\n\n  return type;\n}\n\nexport function getWidget(schema, widget, registeredWidgets = {}) {\n  const type = getSchemaType(schema);\n\n  function mergeOptions(Widget) {\n    // cache return value as property of widget for proper react reconciliation\n    if (!Widget.MergedWidget) {\n      const defaultOptions =\n        (Widget.defaultProps && Widget.defaultProps.options) || {};\n      Widget.MergedWidget = ({ options = {}, ...props }) => (\n        <Widget options={{ ...defaultOptions, ...options }} {...props} />\n      );\n    }\n    return Widget.MergedWidget;\n  }\n\n  if (\n    typeof widget === \"function\" ||\n    ReactIs.isForwardRef(React.createElement(widget)) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeOptions(widget);\n  }\n\n  if (typeof widget !== \"string\") {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (registeredWidgets.hasOwnProperty(widget)) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (!widgetMap.hasOwnProperty(type)) {\n    throw new Error(`No widget for type \"${type}\"`);\n  }\n\n  if (widgetMap[type].hasOwnProperty(widget)) {\n    const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n\n  throw new Error(`No widget \"${widget}\" for type \"${type}\"`);\n}\n\nexport function hasWidget(schema, widget, registeredWidgets = {}) {\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    if (\n      e.message &&\n      (e.message.startsWith(\"No widget\") ||\n        e.message.startsWith(\"Unsupported widget\"))\n    ) {\n      return false;\n    }\n    throw e;\n  }\n}\n\nfunction computeDefaults(\n  _schema,\n  parentDefaults,\n  rootSchema,\n  rawFormData = {},\n  includeUndefinedValues = false\n) {\n  let schema = isObject(_schema) ? _schema : {};\n  const formData = isObject(rawFormData) ? rawFormData : {};\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults = parentDefaults;\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults, schema.default);\n  } else if (\"default\" in schema) {\n    // Use schema defaults for this node.\n    defaults = schema.default;\n  } else if (\"$ref\" in schema) {\n    // Use referenced schema defaults for this node.\n    const refSchema = findSchemaDefinition(schema.$ref, rootSchema);\n    return computeDefaults(\n      refSchema,\n      defaults,\n      rootSchema,\n      formData,\n      includeUndefinedValues\n    );\n  } else if (\"dependencies\" in schema) {\n    const resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return computeDefaults(\n      resolvedSchema,\n      defaults,\n      rootSchema,\n      formData,\n      includeUndefinedValues\n    );\n  } else if (isFixedItems(schema)) {\n    defaults = schema.items.map((itemSchema, idx) =>\n      computeDefaults(\n        itemSchema,\n        Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rootSchema,\n        formData,\n        includeUndefinedValues\n      )\n    );\n  } else if (\"oneOf\" in schema) {\n    schema =\n      schema.oneOf[getMatchingOption(undefined, schema.oneOf, rootSchema)];\n  } else if (\"anyOf\" in schema) {\n    schema =\n      schema.anyOf[getMatchingOption(undefined, schema.anyOf, rootSchema)];\n  }\n\n  // Not defaults defined for this node, fallback to generic typed ones.\n  if (typeof defaults === \"undefined\") {\n    defaults = schema.default;\n  }\n\n  switch (getSchemaType(schema)) {\n    // We need to recur for object schema inner default values.\n    case \"object\":\n      return Object.keys(schema.properties || {}).reduce((acc, key) => {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        let computedDefault = computeDefaults(\n          schema.properties[key],\n          (defaults || {})[key],\n          rootSchema,\n          (formData || {})[key],\n          includeUndefinedValues\n        );\n        if (includeUndefinedValues || computedDefault !== undefined) {\n          acc[key] = computedDefault;\n        }\n        return acc;\n      }, {});\n\n    case \"array\":\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          return computeDefaults(\n            schema.items[idx] || schema.additionalItems || {},\n            item,\n            rootSchema\n          );\n        });\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        defaults = rawFormData.map((item, idx) => {\n          return computeDefaults(\n            schema.items,\n            (defaults || {})[idx],\n            rootSchema,\n            item\n          );\n        });\n      }\n      if (schema.minItems) {\n        if (!isMultiSelect(schema, rootSchema)) {\n          const defaultsLength = defaults ? defaults.length : 0;\n          if (schema.minItems > defaultsLength) {\n            const defaultEntries = defaults || [];\n            // populate the array with the defaults\n            const fillerSchema = Array.isArray(schema.items)\n              ? schema.additionalItems\n              : schema.items;\n            const fillerEntries = fill(\n              new Array(schema.minItems - defaultsLength),\n              computeDefaults(fillerSchema, fillerSchema.defaults, rootSchema)\n            );\n            // then fill up the rest with either the item default or empty, up to minItems\n\n            return defaultEntries.concat(fillerEntries);\n          }\n        } else {\n          return defaults ? defaults : [];\n        }\n      }\n  }\n  return defaults;\n}\n\nexport function getDefaultFormState(\n  _schema,\n  formData,\n  rootSchema = {},\n  includeUndefinedValues = false\n) {\n  if (!isObject(_schema)) {\n    throw new Error(\"Invalid schema: \" + _schema);\n  }\n  const schema = retrieveSchema(_schema, rootSchema, formData);\n  const defaults = computeDefaults(\n    schema,\n    _schema.default,\n    rootSchema,\n    formData,\n    includeUndefinedValues\n  );\n  if (typeof formData === \"undefined\") {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  if (isObject(formData) || Array.isArray(formData)) {\n    return mergeDefaultsWithFormData(defaults, formData);\n  }\n  if (formData === 0 || formData === false || formData === \"\") {\n    return formData;\n  }\n  return formData || defaults;\n}\n\n/**\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n */\nexport function mergeDefaultsWithFormData(defaults, formData) {\n  if (Array.isArray(formData)) {\n    if (!Array.isArray(defaults)) {\n      defaults = [];\n    }\n    return formData.map((value, idx) => {\n      if (defaults[idx]) {\n        return mergeDefaultsWithFormData(defaults[idx], value);\n      }\n      return value;\n    });\n  } else if (isObject(formData)) {\n    const acc = Object.assign({}, defaults); // Prevent mutation of source object.\n    return Object.keys(formData).reduce((acc, key) => {\n      acc[key] = mergeDefaultsWithFormData(\n        defaults ? defaults[key] : {},\n        formData[key]\n      );\n      return acc;\n    }, acc);\n  } else {\n    return formData;\n  }\n}\n\nexport function getUiOptions(uiSchema) {\n  // get all passed options from ui:widget, ui:options, and ui:<optionName>\n  return Object.keys(uiSchema)\n    .filter(key => key.indexOf(\"ui:\") === 0)\n    .reduce((options, key) => {\n      const value = uiSchema[key];\n      if (key === \"ui:widget\" && isObject(value)) {\n        console.warn(\n          \"Setting options via ui:widget object is deprecated, use ui:options instead\"\n        );\n        return {\n          ...options,\n          ...(value.options || {}),\n          widget: value.component,\n        };\n      }\n      if (key === \"ui:options\" && isObject(value)) {\n        return { ...options, ...value };\n      }\n      return { ...options, [key.substring(3)]: value };\n    }, {});\n}\n\nexport function getDisplayLabel(schema, uiSchema, rootSchema) {\n  const uiOptions = getUiOptions(uiSchema);\n  let { label: displayLabel = true } = uiOptions;\n  const schemaType = getSchemaType(schema);\n\n  if (schemaType === \"array\") {\n    displayLabel =\n      isMultiSelect(schema, rootSchema) ||\n      isFilesArray(schema, uiSchema, rootSchema);\n  }\n\n  if (schemaType === \"object\") {\n    displayLabel = false;\n  }\n  if (schemaType === \"boolean\" && !uiSchema[\"ui:widget\"]) {\n    displayLabel = false;\n  }\n  if (uiSchema[\"ui:field\"]) {\n    displayLabel = false;\n  }\n  return displayLabel;\n}\n\nexport function isObject(thing) {\n  if (typeof File !== \"undefined\" && thing instanceof File) {\n    return false;\n  }\n  return typeof thing === \"object\" && thing !== null && !Array.isArray(thing);\n}\n\nexport function mergeObjects(obj1, obj2, concatArrays = false) {\n  // Recursively merge deeply nested objects.\n  var acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      acc[key] = left.concat(right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n\nexport function asNumber(value) {\n  if (value === \"\") {\n    return undefined;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (/\\.$/.test(value)) {\n    // \"3.\" can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n  const n = Number(value);\n  const valid = typeof n === \"number\" && !Number.isNaN(n);\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  return valid ? n : value;\n}\n\nexport function orderProperties(properties, order) {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = arr =>\n    arr.reduce((prev, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = arr =>\n    arr.length > 1\n      ? `properties '${arr.join(\"', '\")}'`\n      : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter(\n    prop => prop === \"*\" || propertyHash[prop]\n  );\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter(prop => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf(\"*\");\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\n        `uiSchema order list does not contain ${errorPropList(rest)}`\n      );\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf(\"*\")) {\n    throw new Error(\"uiSchema order list contains more than one wildcard item\");\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n\n/**\n * This function checks if the given schema matches a single\n * constant value.\n */\nexport function isConstant(schema) {\n  return (\n    (Array.isArray(schema.enum) && schema.enum.length === 1) ||\n    schema.hasOwnProperty(\"const\")\n  );\n}\n\nexport function toConstant(schema) {\n  if (Array.isArray(schema.enum) && schema.enum.length === 1) {\n    return schema.enum[0];\n  } else if (schema.hasOwnProperty(\"const\")) {\n    return schema.const;\n  } else {\n    throw new Error(\"schema cannot be inferred as a constant\");\n  }\n}\n\nexport function isSelect(_schema, rootSchema = {}) {\n  const schema = retrieveSchema(_schema, rootSchema);\n  const altSchemas = schema.oneOf || schema.anyOf;\n  if (Array.isArray(schema.enum)) {\n    return true;\n  } else if (Array.isArray(altSchemas)) {\n    return altSchemas.every(altSchemas => isConstant(altSchemas));\n  }\n  return false;\n}\n\nexport function isMultiSelect(schema, rootSchema = {}) {\n  if (!schema.uniqueItems || !schema.items) {\n    return false;\n  }\n  return isSelect(schema.items, rootSchema);\n}\n\nexport function isFilesArray(schema, uiSchema, rootSchema = {}) {\n  if (uiSchema[\"ui:widget\"] === \"files\") {\n    return true;\n  } else if (schema.items) {\n    const itemsSchema = retrieveSchema(schema.items, rootSchema);\n    return itemsSchema.type === \"string\" && itemsSchema.format === \"data-url\";\n  }\n  return false;\n}\n\nexport function isFixedItems(schema) {\n  return (\n    Array.isArray(schema.items) &&\n    schema.items.length > 0 &&\n    schema.items.every(item => isObject(item))\n  );\n}\n\nexport function allowAdditionalItems(schema) {\n  if (schema.additionalItems === true) {\n    console.warn(\"additionalItems=true is currently not supported\");\n  }\n  return isObject(schema.additionalItems);\n}\n\nexport function optionsList(schema) {\n  if (schema.enum) {\n    return schema.enum.map((value, i) => {\n      const label = (schema.enumNames && schema.enumNames[i]) || String(value);\n      return { label, value };\n    });\n  } else {\n    const altSchemas = schema.oneOf || schema.anyOf;\n    return altSchemas.map((schema, i) => {\n      const value = toConstant(schema);\n      const label = schema.title || String(value);\n      return {\n        schema,\n        label,\n        value,\n      };\n    });\n  }\n}\n\nexport function findSchemaDefinition($ref, rootSchema = {}) {\n  const origRef = $ref;\n  if ($ref.startsWith(\"#\")) {\n    // Decode URI fragment representation.\n    $ref = decodeURIComponent($ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${origRef}.`);\n  }\n  const current = jsonpointer.get(rootSchema, $ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${origRef}.`);\n  }\n  if (current.hasOwnProperty(\"$ref\")) {\n    return findSchemaDefinition(current.$ref, rootSchema);\n  }\n  return current;\n}\n\n// In the case where we have to implicitly create a schema, it is useful to know what type to use\n//  based on the data we are defining\nexport const guessType = function guessType(value) {\n  if (Array.isArray(value)) {\n    return \"array\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (value == null) {\n    return \"null\";\n  } else if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (!isNaN(value)) {\n    return \"number\";\n  } else if (typeof value === \"object\") {\n    return \"object\";\n  }\n  // Default to string if we can't figure it out\n  return \"string\";\n};\n\n// This function will create new \"properties\" items for each key in our formData\nexport function stubExistingAdditionalProperties(\n  schema,\n  rootSchema = {},\n  formData = {}\n) {\n  // Clone the schema so we don't ruin the consumer's original\n  schema = {\n    ...schema,\n    properties: { ...schema.properties },\n  };\n\n  // make sure formData is an object\n  formData = isObject(formData) ? formData : {};\n\n  Object.keys(formData).forEach(key => {\n    if (schema.properties.hasOwnProperty(key)) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties;\n    if (schema.additionalProperties.hasOwnProperty(\"$ref\")) {\n      additionalProperties = retrieveSchema(\n        { $ref: schema.additionalProperties[\"$ref\"] },\n        rootSchema,\n        formData\n      );\n    } else if (schema.additionalProperties.hasOwnProperty(\"type\")) {\n      additionalProperties = { ...schema.additionalProperties };\n    } else {\n      additionalProperties = { type: guessType(formData[key]) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;\n  });\n\n  return schema;\n}\n\nexport function resolveSchema(schema, rootSchema = {}, formData = {}) {\n  if (schema.hasOwnProperty(\"$ref\")) {\n    return resolveReference(schema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"dependencies\")) {\n    const resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return retrieveSchema(resolvedSchema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"allOf\")) {\n    return {\n      ...schema,\n      allOf: schema.allOf.map(allOfSubschema =>\n        retrieveSchema(allOfSubschema, rootSchema, formData)\n      ),\n    };\n  } else {\n    // No $ref or dependencies attribute found, returning the original schema.\n    return schema;\n  }\n}\n\nfunction resolveReference(schema, rootSchema, formData) {\n  // Retrieve the referenced schema definition.\n  const $refSchema = findSchemaDefinition(schema.$ref, rootSchema);\n  // Drop the $ref property of the source schema.\n  const { $ref, ...localSchema } = schema;\n  // Update referenced schema definition with local schema properties.\n  return retrieveSchema(\n    { ...$refSchema, ...localSchema },\n    rootSchema,\n    formData\n  );\n}\n\nexport function retrieveSchema(schema, rootSchema = {}, formData = {}) {\n  if (!isObject(schema)) {\n    return {};\n  }\n  let resolvedSchema = resolveSchema(schema, rootSchema, formData);\n  if (\"allOf\" in schema) {\n    try {\n      resolvedSchema = mergeAllOf({\n        ...resolvedSchema,\n        allOf: resolvedSchema.allOf,\n      });\n    } catch (e) {\n      console.warn(\"could not merge subschemas in allOf:\\n\" + e);\n      const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n      return resolvedSchemaWithoutAllOf;\n    }\n  }\n  const hasAdditionalProperties =\n    resolvedSchema.hasOwnProperty(\"additionalProperties\") &&\n    resolvedSchema.additionalProperties !== false;\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties(\n      resolvedSchema,\n      rootSchema,\n      formData\n    );\n  }\n  return resolvedSchema;\n}\n\nfunction resolveDependencies(schema, rootSchema, formData) {\n  // Drop the dependencies from the source schema.\n  let { dependencies = {}, ...resolvedSchema } = schema;\n  if (\"oneOf\" in resolvedSchema) {\n    resolvedSchema =\n      resolvedSchema.oneOf[\n        getMatchingOption(formData, resolvedSchema.oneOf, rootSchema)\n      ];\n  } else if (\"anyOf\" in resolvedSchema) {\n    resolvedSchema =\n      resolvedSchema.anyOf[\n        getMatchingOption(formData, resolvedSchema.anyOf, rootSchema)\n      ];\n  }\n  return processDependencies(\n    dependencies,\n    resolvedSchema,\n    rootSchema,\n    formData\n  );\n}\nfunction processDependencies(\n  dependencies,\n  resolvedSchema,\n  rootSchema,\n  formData\n) {\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (formData[dependencyKey] === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (\n      resolvedSchema.properties &&\n      !(dependencyKey in resolvedSchema.properties)\n    ) {\n      continue;\n    }\n    const {\n      [dependencyKey]: dependencyValue,\n      ...remainingDependencies\n    } = dependencies;\n    if (Array.isArray(dependencyValue)) {\n      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      resolvedSchema = withDependentSchema(\n        resolvedSchema,\n        rootSchema,\n        formData,\n        dependencyKey,\n        dependencyValue\n      );\n    }\n    return processDependencies(\n      remainingDependencies,\n      resolvedSchema,\n      rootSchema,\n      formData\n    );\n  }\n  return resolvedSchema;\n}\n\nfunction withDependentProperties(schema, additionallyRequired) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\nfunction withDependentSchema(\n  schema,\n  rootSchema,\n  formData,\n  dependencyKey,\n  dependencyValue\n) {\n  let { oneOf, ...dependentSchema } = retrieveSchema(\n    dependencyValue,\n    rootSchema,\n    formData\n  );\n  schema = mergeSchemas(schema, dependentSchema);\n  // Since it does not contain oneOf, we return the original schema.\n  if (oneOf === undefined) {\n    return schema;\n  } else if (!Array.isArray(oneOf)) {\n    throw new Error(`invalid: it is some ${typeof oneOf} instead of an array`);\n  }\n  // Resolve $refs inside oneOf.\n  const resolvedOneOf = oneOf.map(subschema =>\n    subschema.hasOwnProperty(\"$ref\")\n      ? resolveReference(subschema, rootSchema, formData)\n      : subschema\n  );\n  return withExactlyOneSubschema(\n    schema,\n    rootSchema,\n    formData,\n    dependencyKey,\n    resolvedOneOf\n  );\n}\n\nfunction withExactlyOneSubschema(\n  schema,\n  rootSchema,\n  formData,\n  dependencyKey,\n  oneOf\n) {\n  const validSubschemas = oneOf.filter(subschema => {\n    if (!subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema = {\n        type: \"object\",\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      };\n      const { errors } = validateFormData(formData, conditionSchema);\n      return errors.length === 0;\n    }\n  });\n  if (validSubschemas.length !== 1) {\n    console.warn(\n      \"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\"\n    );\n    return schema;\n  }\n  const subschema = validSubschemas[0];\n  const {\n    [dependencyKey]: conditionPropertySchema,\n    ...dependentSubschema\n  } = subschema.properties;\n  const dependentSchema = { ...subschema, properties: dependentSubschema };\n  return mergeSchemas(\n    schema,\n    retrieveSchema(dependentSchema, rootSchema, formData)\n  );\n}\n\n// Recursively merge deeply nested schemas.\n// The difference between mergeSchemas and mergeObjects\n// is that mergeSchemas only concats arrays for\n// values under the \"required\" keyword, and when it does,\n// it doesn't include duplicate values.\nexport function mergeSchemas(obj1, obj2) {\n  var acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === \"object\" || getSchemaType(obj2) === \"object\") &&\n      key === \"required\" &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging\n      // \"required\" fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === \"[object Arguments]\";\n}\n\nexport function deepEquals(a, b, ca = [], cb = []) {\n  // Partially extracted from node-deeper and adapted to exclude comparison\n  // checks for functions.\n  // https://github.com/othiym23/node-deeper\n  if (a === b) {\n    return true;\n  } else if (typeof a === \"function\" || typeof b === \"function\") {\n    // Assume all functions are equivalent\n    // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n    return true;\n  } else if (typeof a !== \"object\" || typeof b !== \"object\") {\n    return false;\n  } else if (a === null || b === null) {\n    return false;\n  } else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  } else if (a instanceof RegExp && b instanceof RegExp) {\n    return (\n      a.source === b.source &&\n      a.global === b.global &&\n      a.multiline === b.multiline &&\n      a.lastIndex === b.lastIndex &&\n      a.ignoreCase === b.ignoreCase\n    );\n  } else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) {\n      return false;\n    }\n    let slice = Array.prototype.slice;\n    return deepEquals(slice.call(a), slice.call(b), ca, cb);\n  } else {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    let ka = Object.keys(a);\n    let kb = Object.keys(b);\n    // don't bother with stack acrobatics if there's nothing there\n    if (ka.length === 0 && kb.length === 0) {\n      return true;\n    }\n    if (ka.length !== kb.length) {\n      return false;\n    }\n\n    let cal = ca.length;\n    while (cal--) {\n      if (ca[cal] === a) {\n        return cb[cal] === b;\n      }\n    }\n    ca.push(a);\n    cb.push(b);\n\n    ka.sort();\n    kb.sort();\n    for (var j = ka.length - 1; j >= 0; j--) {\n      if (ka[j] !== kb[j]) {\n        return false;\n      }\n    }\n\n    let key;\n    for (let k = ka.length - 1; k >= 0; k--) {\n      key = ka[k];\n      if (!deepEquals(a[key], b[key], ca, cb)) {\n        return false;\n      }\n    }\n\n    ca.pop();\n    cb.pop();\n\n    return true;\n  }\n}\n\nexport function shouldRender(comp, nextProps, nextState) {\n  const { props, state } = comp;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n\nexport function toIdSchema(\n  schema,\n  id,\n  rootSchema,\n  formData = {},\n  idPrefix = \"root\"\n) {\n  const idSchema = {\n    $id: id || idPrefix,\n  };\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    const _schema = retrieveSchema(schema, rootSchema, formData);\n    return toIdSchema(_schema, id, rootSchema, formData, idPrefix);\n  }\n  if (\"items\" in schema && !schema.items.$ref) {\n    return toIdSchema(schema.items, id, rootSchema, formData, idPrefix);\n  }\n  if (schema.type !== \"object\") {\n    return idSchema;\n  }\n  for (const name in schema.properties || {}) {\n    const field = schema.properties[name];\n    const fieldId = idSchema.$id + \"_\" + name;\n    idSchema[name] = toIdSchema(\n      isObject(field) ? field : {},\n      fieldId,\n      rootSchema,\n      // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      (formData || {})[name],\n      idPrefix\n    );\n  }\n  return idSchema;\n}\n\nexport function toPathSchema(schema, name = \"\", rootSchema, formData = {}) {\n  const pathSchema = {\n    $name: name.replace(/^\\./, \"\"),\n  };\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    const _schema = retrieveSchema(schema, rootSchema, formData);\n    return toPathSchema(_schema, name, rootSchema, formData);\n  }\n\n  if (schema.hasOwnProperty(\"additionalProperties\")) {\n    pathSchema.__rjsf_additionalProperties = true;\n  }\n\n  if (schema.hasOwnProperty(\"items\") && Array.isArray(formData)) {\n    formData.forEach((element, i) => {\n      pathSchema[i] = toPathSchema(\n        schema.items,\n        `${name}.${i}`,\n        rootSchema,\n        element\n      );\n    });\n  } else if (schema.hasOwnProperty(\"properties\")) {\n    for (const property in schema.properties) {\n      pathSchema[property] = toPathSchema(\n        schema.properties[property],\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        (formData || {})[property]\n      );\n    }\n  }\n  return pathSchema;\n}\n\nexport function parseDateString(dateString, includeTime = true) {\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0,\n    };\n  }\n  const date = new Date(dateString);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error(\"Unable to parse date \" + dateString);\n  }\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1, // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0,\n  };\n}\n\nexport function toDateString(\n  { year, month, day, hour = 0, minute = 0, second = 0 },\n  time = true\n) {\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  const datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n\nexport function utcToLocal(jsonDate) {\n  if (!jsonDate) {\n    return \"\";\n  }\n\n  // required format of `\"yyyy-MM-ddThh:mm\" followed by optional \":ss\" or \":ss.SSS\"\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n  const date = new Date(jsonDate);\n\n  const yyyy = pad(date.getFullYear(), 4);\n  const MM = pad(date.getMonth() + 1, 2);\n  const dd = pad(date.getDate(), 2);\n  const hh = pad(date.getHours(), 2);\n  const mm = pad(date.getMinutes(), 2);\n  const ss = pad(date.getSeconds(), 2);\n  const SSS = pad(date.getMilliseconds(), 3);\n\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\n}\n\nexport function localToUTC(dateString) {\n  if (dateString) {\n    return new Date(dateString).toJSON();\n  }\n}\n\nexport function pad(num, size) {\n  let s = String(num);\n  while (s.length < size) {\n    s = \"0\" + s;\n  }\n  return s;\n}\n\nexport function dataURItoBlob(dataURI) {\n  // Split metadata from data\n  const splitted = dataURI.split(\",\");\n  // Split params\n  const params = splitted[0].split(\";\");\n  // Get mime-type from params\n  const type = params[0].replace(\"data:\", \"\");\n  // Filter the name property from params\n  const properties = params.filter(param => {\n    return param.split(\"=\")[0] === \"name\";\n  });\n  // Look for the name and use unknown if no name property.\n  let name;\n  if (properties.length !== 1) {\n    name = \"unknown\";\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here.\n    name = properties[0].split(\"=\")[1];\n  }\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  const binary = atob(splitted[1]);\n  const array = [];\n  for (let i = 0; i < binary.length; i++) {\n    array.push(binary.charCodeAt(i));\n  }\n  // Create the blob object\n  const blob = new window.Blob([new Uint8Array(array)], { type });\n\n  return { blob, name };\n}\n\nexport function rangeSpec(schema) {\n  const spec = {};\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n  return spec;\n}\n\nexport function getMatchingOption(formData, options, rootSchema) {\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option.properties).map(key => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n\n// Check to see if a schema specifies that a value must be true\nexport function schemaRequiresTrueValue(schema) {\n  // Check if const is a truthy value\n  if (schema.const) {\n    return true;\n  }\n\n  // Check if an enum has a single value of true\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\n    return true;\n  }\n\n  // If anyOf has a single value, evaluate the subschema\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0]);\n  }\n\n  // If oneOf has a single value, evaluate the subschema\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0]);\n  }\n\n  // Evaluate each subschema in allOf, to see if one of them requires a true\n  // value\n  if (schema.allOf) {\n    return schema.allOf.some(schemaRequiresTrueValue);\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}