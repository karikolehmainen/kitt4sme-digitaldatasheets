{"ast":null,"code":"import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { asNumber, guessType } from \"../../utils\";\nvar nums = new Set([\"number\", \"integer\"]);\n/**\n * This is a silly limitation in the DOM where option change event values are\n * always retrieved as strings.\n */\n\nfunction processValue(schema, value) {\n  // \"enum\" is a reserved word, so only \"type\" and \"items\" can be destructured\n  var type = schema.type,\n      items = schema.items;\n\n  if (value === \"\") {\n    return undefined;\n  } else if (type === \"array\" && items && nums.has(items.type)) {\n    return value.map(asNumber);\n  } else if (type === \"boolean\") {\n    return value === \"true\";\n  } else if (type === \"number\") {\n    return asNumber(value);\n  } // If type is undefined, but an enum is present, try and infer the type from\n  // the enum values\n\n\n  if (schema[\"enum\"]) {\n    if (schema[\"enum\"].every(function (x) {\n      return guessType(x) === \"number\";\n    })) {\n      return asNumber(value);\n    } else if (schema[\"enum\"].every(function (x) {\n      return guessType(x) === \"boolean\";\n    })) {\n      return value === \"true\";\n    }\n  }\n\n  return value;\n}\n\nfunction getValue(event, multiple) {\n  if (multiple) {\n    return [].slice.call(event.target.options).filter(function (o) {\n      return o.selected;\n    }).map(function (o) {\n      return o.value;\n    });\n  } else {\n    return event.target.value;\n  }\n}\n\nfunction SelectWidget(props) {\n  var schema = props.schema,\n      id = props.id,\n      options = props.options,\n      value = props.value,\n      required = props.required,\n      disabled = props.disabled,\n      readonly = props.readonly,\n      multiple = props.multiple,\n      autofocus = props.autofocus,\n      _onChange = props.onChange,\n      onBlur = props.onBlur,\n      onFocus = props.onFocus,\n      placeholder = props.placeholder;\n  var enumOptions = options.enumOptions,\n      enumDisabled = options.enumDisabled;\n  var emptyValue = multiple ? [] : \"\";\n  return React.createElement(\"select\", {\n    id: id,\n    multiple: multiple,\n    className: \"form-control\",\n    value: typeof value === \"undefined\" ? emptyValue : value,\n    required: required,\n    disabled: disabled || readonly,\n    autoFocus: autofocus,\n    onBlur: onBlur && function (event) {\n      var newValue = getValue(event, multiple);\n      onBlur(id, processValue(schema, newValue));\n    },\n    onFocus: onFocus && function (event) {\n      var newValue = getValue(event, multiple);\n      onFocus(id, processValue(schema, newValue));\n    },\n    onChange: function onChange(event) {\n      var newValue = getValue(event, multiple);\n\n      _onChange(processValue(schema, newValue));\n    }\n  }, !multiple && schema[\"default\"] === undefined && React.createElement(\"option\", {\n    value: \"\"\n  }, placeholder), enumOptions.map(function (_ref, i) {\n    var value = _ref.value,\n        label = _ref.label;\n    var disabled = enumDisabled && enumDisabled.indexOf(value) != -1;\n    return React.createElement(\"option\", {\n      key: i,\n      value: value,\n      disabled: disabled\n    }, label);\n  }));\n}\n\nSelectWidget.defaultProps = {\n  autofocus: false\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  SelectWidget.propTypes = {\n    schema: PropTypes.object.isRequired,\n    id: PropTypes.string.isRequired,\n    options: PropTypes.shape({\n      enumOptions: PropTypes.array\n    }).isRequired,\n    value: PropTypes.any,\n    required: PropTypes.bool,\n    disabled: PropTypes.bool,\n    readonly: PropTypes.bool,\n    multiple: PropTypes.bool,\n    autofocus: PropTypes.bool,\n    onChange: PropTypes.func,\n    onBlur: PropTypes.func,\n    onFocus: PropTypes.func\n  };\n}\n\nexport default SelectWidget;","map":{"version":3,"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,SAAP,MAAsB,YAAtB;AAEA,SAASC,QAAT,EAAmBC,SAAnB,QAAoC,aAApC;AAEA,IAAMC,IAAI,GAAG,IAAIC,GAAJ,CAAQ,CAAC,QAAD,EAAW,SAAX,CAAR,CAAb;AAEA;;;;;AAIA,SAASC,YAAT,CAAsBC,MAAtB,EAA8BC,KAA9B,EAAqC;AACnC;AADmC,MAE3BC,IAF2B,GAEXF,MAFW,CAE3BE,IAF2B;AAAA,MAErBC,KAFqB,GAEXH,MAFW,CAErBG,KAFqB;;AAGnC,MAAIF,KAAK,KAAK,EAAd,EAAkB;AAChB,WAAOG,SAAP;AADF,SAEO,IAAIF,IAAI,KAAK,OAATA,IAAoBC,KAApBD,IAA6BL,IAAI,CAACQ,GAALR,CAASM,KAAK,CAACD,IAAfL,CAAjC,EAAuD;AAC5D,WAAOI,KAAK,CAACK,GAANL,CAAUN,QAAVM,CAAP;AADK,SAEA,IAAIC,IAAI,KAAK,SAAb,EAAwB;AAC7B,WAAOD,KAAK,KAAK,MAAjB;AADK,SAEA,IAAIC,IAAI,KAAK,QAAb,EAAuB;AAC5B,WAAOP,QAAQ,CAACM,KAAD,CAAf;AAViC,IAanC;AACA;;;AACA,MAAID,MAAM,QAAV,EAAiB;AACf,QAAIA,MAAM,QAANA,CAAYO,KAAZP,CAAkB,aAAC;AAAA,aAAIJ,SAAS,CAACY,CAAD,CAATZ,KAAiB,QAArB;AAAnB,MAAJ,EAAuD;AACrD,aAAOD,QAAQ,CAACM,KAAD,CAAf;AADF,WAEO,IAAID,MAAM,QAANA,CAAYO,KAAZP,CAAkB,aAAC;AAAA,aAAIJ,SAAS,CAACY,CAAD,CAATZ,KAAiB,SAArB;AAAnB,MAAJ,EAAwD;AAC7D,aAAOK,KAAK,KAAK,MAAjB;AACD;AACF;;AAED,SAAOA,KAAP;AACD;;AAED,SAASQ,QAAT,CAAkBC,KAAlB,EAAyBC,QAAzB,EAAmC;AACjC,MAAIA,QAAJ,EAAc;AACZ,WAAO,GAAGC,KAAH,CACJC,IADI,CACCH,KAAK,CAACI,MAANJ,CAAaK,OADd,EAEJC,MAFI,CAEG,aAAC;AAAA,aAAIC,CAAC,CAACC,QAAN;AAFJ,OAGJZ,GAHI,CAGA,aAAC;AAAA,aAAIW,CAAC,CAAChB,KAAN;AAHD,MAAP;AADF,SAKO;AACL,WAAOS,KAAK,CAACI,MAANJ,CAAaT,KAApB;AACD;AACF;;AAED,SAASkB,YAAT,CAAsBC,KAAtB,EAA6B;AAAA,MAEzBpB,MAFyB,GAevBoB,KAfuB,CAEzBpB,MAFyB;AAAA,MAGzBqB,EAHyB,GAevBD,KAfuB,CAGzBC,EAHyB;AAAA,MAIzBN,OAJyB,GAevBK,KAfuB,CAIzBL,OAJyB;AAAA,MAKzBd,KALyB,GAevBmB,KAfuB,CAKzBnB,KALyB;AAAA,MAMzBqB,QANyB,GAevBF,KAfuB,CAMzBE,QANyB;AAAA,MAOzBC,QAPyB,GAevBH,KAfuB,CAOzBG,QAPyB;AAAA,MAQzBC,QARyB,GAevBJ,KAfuB,CAQzBI,QARyB;AAAA,MASzBb,QATyB,GAevBS,KAfuB,CASzBT,QATyB;AAAA,MAUzBc,SAVyB,GAevBL,KAfuB,CAUzBK,SAVyB;AAAA,MAWzBC,SAXyB,GAevBN,KAfuB,CAWzBM,QAXyB;AAAA,MAYzBC,MAZyB,GAevBP,KAfuB,CAYzBO,MAZyB;AAAA,MAazBC,OAbyB,GAevBR,KAfuB,CAazBQ,OAbyB;AAAA,MAczBC,WAdyB,GAevBT,KAfuB,CAczBS,WAdyB;AAAA,MAgBnBC,WAhBmB,GAgBWf,OAhBX,CAgBnBe,WAhBmB;AAAA,MAgBNC,YAhBM,GAgBWhB,OAhBX,CAgBNgB,YAhBM;AAiB3B,MAAMC,UAAU,GAAGrB,QAAQ,GAAG,EAAH,GAAQ,EAAnC;AACA,SACElB;AACE4B,MAAE,EAAEA,EADN;AAEEV,YAAQ,EAAEA,QAFZ;AAGEsB,aAAS,EAAC,cAHZ;AAIEhC,SAAK,EAAE,OAAOA,KAAP,KAAiB,WAAjB,GAA+B+B,UAA/B,GAA4C/B,KAJrD;AAKEqB,YAAQ,EAAEA,QALZ;AAMEC,YAAQ,EAAEA,QAAQ,IAAIC,QANxB;AAOEU,aAAS,EAAET,SAPb;AAQEE,UAAM,EACJA,MAAM,IACL,iBAAS;AACR,UAAMQ,QAAQ,GAAG1B,QAAQ,CAACC,KAAD,EAAQC,QAAR,CAAzB;AACAgB,YAAM,CAACN,EAAD,EAAKtB,YAAY,CAACC,MAAD,EAASmC,QAAT,CAAjB,CAANR;AAZN;AAeEC,WAAO,EACLA,OAAO,IACN,iBAAS;AACR,UAAMO,QAAQ,GAAG1B,QAAQ,CAACC,KAAD,EAAQC,QAAR,CAAzB;AACAiB,aAAO,CAACP,EAAD,EAAKtB,YAAY,CAACC,MAAD,EAASmC,QAAT,CAAjB,CAAPP;AAnBN;AAsBEF,YAAQ,EAAE,yBAAS;AACjB,UAAMS,QAAQ,GAAG1B,QAAQ,CAACC,KAAD,EAAQC,QAAR,CAAzB;;AACAe,eAAQ,CAAC3B,YAAY,CAACC,MAAD,EAASmC,QAAT,CAAb,CAART;AACD;AAzBH,KA0BG,CAACf,QAAD,IAAaX,MAAM,WAANA,KAAmBI,SAAhC,IACCX;AAAQQ,SAAK,EAAC;AAAd,KAAkB4B,WAAlB,CA3BJ,EA6BGC,WAAW,CAACxB,GAAZwB,CAAgB,gBAAmBM,CAAnB,EAAyB;AAAA,QAAtBnC,KAAsB,QAAtBA,KAAsB;AAAA,QAAfoC,KAAe,QAAfA,KAAe;AACxC,QAAMd,QAAQ,GAAGQ,YAAY,IAAIA,YAAY,CAACO,OAAbP,CAAqB9B,KAArB8B,KAA+B,CAAC,CAAjE;AACA,WACEtC;AAAQ8C,SAAG,EAAEH,CAAb;AAAgBnC,WAAK,EAAEA,KAAvB;AAA8BsB,cAAQ,EAAEA;AAAxC,OACGc,KADH,CADF;AAFD,IA7BH,CADF;AAwCD;;AAEDlB,YAAY,CAACqB,YAAbrB,GAA4B;AAC1BM,WAAS,EAAE;AADe,CAA5BN;;AAIA,IAAIsB,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,YAA7B,EAA2C;AACzCtB,cAAY,CAACyB,SAAbzB,GAAyB;AACvBnB,UAAM,EAAEN,SAAS,CAACmD,MAAVnD,CAAiBoD,UADF;AAEvBzB,MAAE,EAAE3B,SAAS,CAACqD,MAAVrD,CAAiBoD,UAFE;AAGvB/B,WAAO,EAAErB,SAAS,CAACsD,KAAVtD,CAAgB;AACvBoC,iBAAW,EAAEpC,SAAS,CAACuD;AADA,KAAhBvD,EAENoD,UALoB;AAMvB7C,SAAK,EAAEP,SAAS,CAACwD,GANM;AAOvB5B,YAAQ,EAAE5B,SAAS,CAACyD,IAPG;AAQvB5B,YAAQ,EAAE7B,SAAS,CAACyD,IARG;AASvB3B,YAAQ,EAAE9B,SAAS,CAACyD,IATG;AAUvBxC,YAAQ,EAAEjB,SAAS,CAACyD,IAVG;AAWvB1B,aAAS,EAAE/B,SAAS,CAACyD,IAXE;AAYvBzB,YAAQ,EAAEhC,SAAS,CAAC0D,IAZG;AAavBzB,UAAM,EAAEjC,SAAS,CAAC0D,IAbK;AAcvBxB,WAAO,EAAElC,SAAS,CAAC0D;AAdI,GAAzBjC;AAgBD;;AAED,eAAeA,YAAf","names":["React","PropTypes","asNumber","guessType","nums","Set","processValue","schema","value","type","items","undefined","has","map","every","x","getValue","event","multiple","slice","call","target","options","filter","o","selected","SelectWidget","props","id","required","disabled","readonly","autofocus","onChange","onBlur","onFocus","placeholder","enumOptions","enumDisabled","emptyValue","className","autoFocus","newValue","i","label","indexOf","key","defaultProps","process","env","NODE_ENV","propTypes","object","isRequired","string","shape","array","any","bool","func"],"sources":["/core/src/components/widgets/SelectWidget.js"],"sourcesContent":["import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport { asNumber, guessType } from \"../../utils\";\n\nconst nums = new Set([\"number\", \"integer\"]);\n\n/**\n * This is a silly limitation in the DOM where option change event values are\n * always retrieved as strings.\n */\nfunction processValue(schema, value) {\n  // \"enum\" is a reserved word, so only \"type\" and \"items\" can be destructured\n  const { type, items } = schema;\n  if (value === \"\") {\n    return undefined;\n  } else if (type === \"array\" && items && nums.has(items.type)) {\n    return value.map(asNumber);\n  } else if (type === \"boolean\") {\n    return value === \"true\";\n  } else if (type === \"number\") {\n    return asNumber(value);\n  }\n\n  // If type is undefined, but an enum is present, try and infer the type from\n  // the enum values\n  if (schema.enum) {\n    if (schema.enum.every(x => guessType(x) === \"number\")) {\n      return asNumber(value);\n    } else if (schema.enum.every(x => guessType(x) === \"boolean\")) {\n      return value === \"true\";\n    }\n  }\n\n  return value;\n}\n\nfunction getValue(event, multiple) {\n  if (multiple) {\n    return [].slice\n      .call(event.target.options)\n      .filter(o => o.selected)\n      .map(o => o.value);\n  } else {\n    return event.target.value;\n  }\n}\n\nfunction SelectWidget(props) {\n  const {\n    schema,\n    id,\n    options,\n    value,\n    required,\n    disabled,\n    readonly,\n    multiple,\n    autofocus,\n    onChange,\n    onBlur,\n    onFocus,\n    placeholder,\n  } = props;\n  const { enumOptions, enumDisabled } = options;\n  const emptyValue = multiple ? [] : \"\";\n  return (\n    <select\n      id={id}\n      multiple={multiple}\n      className=\"form-control\"\n      value={typeof value === \"undefined\" ? emptyValue : value}\n      required={required}\n      disabled={disabled || readonly}\n      autoFocus={autofocus}\n      onBlur={\n        onBlur &&\n        (event => {\n          const newValue = getValue(event, multiple);\n          onBlur(id, processValue(schema, newValue));\n        })\n      }\n      onFocus={\n        onFocus &&\n        (event => {\n          const newValue = getValue(event, multiple);\n          onFocus(id, processValue(schema, newValue));\n        })\n      }\n      onChange={event => {\n        const newValue = getValue(event, multiple);\n        onChange(processValue(schema, newValue));\n      }}>\n      {!multiple && schema.default === undefined && (\n        <option value=\"\">{placeholder}</option>\n      )}\n      {enumOptions.map(({ value, label }, i) => {\n        const disabled = enumDisabled && enumDisabled.indexOf(value) != -1;\n        return (\n          <option key={i} value={value} disabled={disabled}>\n            {label}\n          </option>\n        );\n      })}\n    </select>\n  );\n}\n\nSelectWidget.defaultProps = {\n  autofocus: false,\n};\n\nif (process.env.NODE_ENV !== \"production\") {\n  SelectWidget.propTypes = {\n    schema: PropTypes.object.isRequired,\n    id: PropTypes.string.isRequired,\n    options: PropTypes.shape({\n      enumOptions: PropTypes.array,\n    }).isRequired,\n    value: PropTypes.any,\n    required: PropTypes.bool,\n    disabled: PropTypes.bool,\n    readonly: PropTypes.bool,\n    multiple: PropTypes.bool,\n    autofocus: PropTypes.bool,\n    onChange: PropTypes.func,\n    onBlur: PropTypes.func,\n    onFocus: PropTypes.func,\n  };\n}\n\nexport default SelectWidget;\n"]},"metadata":{},"sourceType":"module"}