{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport toPath from \"lodash/toPath\";\nimport Ajv from \"ajv\";\nvar ajv = createAjvInstance();\nimport { deepEquals, getDefaultFormState } from \"./utils\";\nvar formerCustomFormats = null;\nvar formerMetaSchema = null;\nvar ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\nimport { isObject, mergeObjects } from \"./utils\";\n\nfunction createAjvInstance() {\n  var ajv = new Ajv({\n    errorDataPath: \"property\",\n    allErrors: true,\n    multipleOfPrecision: 8,\n    schemaId: \"auto\",\n    unknownFormats: \"ignore\"\n  }); // add custom formats\n\n  ajv.addFormat(\"data-url\", /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/);\n  ajv.addFormat(\"color\", /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/);\n  return ajv;\n}\n\nfunction toErrorSchema(errors) {\n  // Transforms a ajv validation errors list:\n  // [\n  //   {property: \".level1.level2[2].level3\", message: \"err a\"},\n  //   {property: \".level1.level2[2].level3\", message: \"err b\"},\n  //   {property: \".level1.level2[4].level3\", message: \"err b\"},\n  // ]\n  // Into an error tree:\n  // {\n  //   level1: {\n  //     level2: {\n  //       2: {level3: {errors: [\"err a\", \"err b\"]}},\n  //       4: {level3: {errors: [\"err b\"]}},\n  //     }\n  //   }\n  // };\n  if (!errors.length) {\n    return {};\n  }\n\n  return errors.reduce(function (errorSchema, error) {\n    var property = error.property,\n        message = error.message;\n    var path = toPath(property);\n    var parent = errorSchema; // If the property is at the root (.level1) then toPath creates\n    // an empty array element at the first index. Remove it.\n\n    if (path.length > 0 && path[0] === \"\") {\n      path.splice(0, 1);\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = path.slice(0)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var segment = _step.value;\n\n        if (!(segment in parent)) {\n          parent[segment] = {};\n        }\n\n        parent = parent[segment];\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (Array.isArray(parent.__errors)) {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // \"errors\" (see `validate.createErrorHandler`).\n      parent.__errors = parent.__errors.concat(message);\n    } else {\n      if (message) {\n        parent.__errors = [message];\n      }\n    }\n\n    return errorSchema;\n  }, {});\n}\n\nexport function toErrorList(errorSchema) {\n  var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"root\"; // XXX: We should transform fieldName as a full field path string.\n\n  var errorList = [];\n\n  if (\"__errors\" in errorSchema) {\n    errorList = errorList.concat(errorSchema.__errors.map(function (stack) {\n      return {\n        stack: \"\".concat(fieldName, \": \").concat(stack)\n      };\n    }));\n  }\n\n  return Object.keys(errorSchema).reduce(function (acc, key) {\n    if (key !== \"__errors\") {\n      acc = acc.concat(toErrorList(errorSchema[key], key));\n    }\n\n    return acc;\n  }, errorList);\n}\n\nfunction createErrorHandler(formData) {\n  var handler = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // \"errors\" (see `utils.toErrorSchema`).\n    __errors: [],\n    addError: function addError(message) {\n      this.__errors.push(message);\n    }\n  };\n\n  if (isObject(formData)) {\n    return Object.keys(formData).reduce(function (acc, key) {\n      return _objectSpread({}, acc, _defineProperty({}, key, createErrorHandler(formData[key])));\n    }, handler);\n  }\n\n  if (Array.isArray(formData)) {\n    return formData.reduce(function (acc, value, key) {\n      return _objectSpread({}, acc, _defineProperty({}, key, createErrorHandler(value)));\n    }, handler);\n  }\n\n  return handler;\n}\n\nfunction unwrapErrorHandler(errorHandler) {\n  return Object.keys(errorHandler).reduce(function (acc, key) {\n    if (key === \"addError\") {\n      return acc;\n    } else if (key === \"__errors\") {\n      return _objectSpread({}, acc, _defineProperty({}, key, errorHandler[key]));\n    }\n\n    return _objectSpread({}, acc, _defineProperty({}, key, unwrapErrorHandler(errorHandler[key])));\n  }, {});\n}\n/**\n * Transforming the error output from ajv to format used by jsonschema.\n * At some point, components should be updated to support ajv.\n */\n\n\nfunction transformAjvErrors() {\n  var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  if (errors === null) {\n    return [];\n  }\n\n  return errors.map(function (e) {\n    var dataPath = e.dataPath,\n        keyword = e.keyword,\n        message = e.message,\n        params = e.params,\n        schemaPath = e.schemaPath;\n    var property = \"\".concat(dataPath); // put data in expected format\n\n    return {\n      name: keyword,\n      property: property,\n      message: message,\n      params: params,\n      // specific to ajv\n      stack: \"\".concat(property, \" \").concat(message).trim(),\n      schemaPath: schemaPath\n    };\n  });\n}\n/**\n * This function processes the formData with a user `validate` contributed\n * function, which receives the form data and an `errorHandler` object that\n * will be used to add custom validation errors for each field.\n */\n\n\nexport default function validateFormData(formData, schema, customValidate, transformErrors) {\n  var additionalMetaSchemas = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var customFormats = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {}; // Include form data with undefined values, which is required for validation.\n\n  var rootSchema = schema;\n  formData = getDefaultFormState(schema, formData, rootSchema, true);\n  var newMetaSchemas = !deepEquals(formerMetaSchema, additionalMetaSchemas);\n  var newFormats = !deepEquals(formerCustomFormats, customFormats);\n\n  if (newMetaSchemas || newFormats) {\n    ajv = createAjvInstance();\n  } // add more schemas to validate against\n\n\n  if (additionalMetaSchemas && newMetaSchemas && Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n    formerMetaSchema = additionalMetaSchemas;\n  } // add more custom formats to validate against\n\n\n  if (customFormats && newFormats && isObject(customFormats)) {\n    Object.keys(customFormats).forEach(function (formatName) {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n    formerCustomFormats = customFormats;\n  }\n\n  var validationError = null;\n\n  try {\n    ajv.validate(schema, formData);\n  } catch (err) {\n    validationError = err;\n  }\n\n  var errors = transformAjvErrors(ajv.errors); // Clear errors to prevent persistent errors, see #1104\n\n  ajv.errors = null;\n  var noProperMetaSchema = validationError && validationError.message && typeof validationError.message === \"string\" && validationError.message.includes(\"no schema with key or ref \");\n\n  if (noProperMetaSchema) {\n    errors = [].concat(_toConsumableArray(errors), [{\n      stack: validationError.message\n    }]);\n  }\n\n  if (typeof transformErrors === \"function\") {\n    errors = transformErrors(errors);\n  }\n\n  var errorSchema = toErrorSchema(errors);\n\n  if (noProperMetaSchema) {\n    errorSchema = _objectSpread({}, errorSchema, {\n      $schema: {\n        __errors: [validationError.message]\n      }\n    });\n  }\n\n  if (typeof customValidate !== \"function\") {\n    return {\n      errors: errors,\n      errorSchema: errorSchema\n    };\n  }\n\n  var errorHandler = customValidate(formData, createErrorHandler(formData));\n  var userErrorSchema = unwrapErrorHandler(errorHandler);\n  var newErrorSchema = mergeObjects(errorSchema, userErrorSchema, true); // XXX: The errors list produced is not fully compliant with the format\n  // exposed by the jsonschema lib, which contains full field paths and other\n  // properties.\n\n  var newErrors = toErrorList(newErrorSchema);\n  return {\n    errors: newErrors,\n    errorSchema: newErrorSchema\n  };\n}\n/**\n * Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n * This is used in isValid to make references to the rootSchema\n */\n\nexport function withIdRefPrefix(schemaNode) {\n  var obj = schemaNode;\n\n  if (schemaNode.constructor === Object) {\n    obj = _objectSpread({}, schemaNode);\n\n    for (var key in obj) {\n      var value = obj[key];\n\n      if (key === \"$ref\" && typeof value === \"string\" && value.startsWith(\"#\")) {\n        obj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        obj[key] = withIdRefPrefix(value);\n      }\n    }\n  } else if (Array.isArray(schemaNode)) {\n    obj = _toConsumableArray(schemaNode);\n\n    for (var i = 0; i < obj.length; i++) {\n      obj[i] = withIdRefPrefix(obj[i]);\n    }\n  }\n\n  return obj;\n}\n/**\n * Validates data against a schema, returning true if the data is valid, or\n * false otherwise. If the schema is invalid, then this function will return\n * false.\n */\n\nexport function isValid(schema, data, rootSchema) {\n  try {\n    // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n    // then rewrite the schema ref's to point to the rootSchema\n    // this accounts for the case where schema have references to models\n    // that lives in the rootSchema but not in the schema in question.\n    return ajv.addSchema(rootSchema, ROOT_SCHEMA_PREFIX).validate(withIdRefPrefix(schema), data);\n  } catch (e) {\n    return false;\n  } finally {\n    // make sure we remove the rootSchema from the global ajv instance\n    ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n  }\n}","map":{"version":3,"mappings":"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","names":["toPath","Ajv","ajv","createAjvInstance","deepEquals","getDefaultFormState","formerCustomFormats","formerMetaSchema","ROOT_SCHEMA_PREFIX","isObject","mergeObjects","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","addFormat","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","parent","splice","slice","Symbol","segment","_didIteratorError","_iteratorError","_iterator","Array","isArray","__errors","concat","toErrorList","fieldName","errorList","map","stack","Object","keys","acc","key","createErrorHandler","formData","handler","addError","push","value","unwrapErrorHandler","errorHandler","transformAjvErrors","dataPath","e","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","additionalMetaSchemas","customFormats","rootSchema","newMetaSchemas","newFormats","addMetaSchema","forEach","formatName","validationError","validate","err","noProperMetaSchema","includes","$schema","userErrorSchema","newErrorSchema","newErrors","withIdRefPrefix","schemaNode","obj","constructor","startsWith","i","isValid","data","addSchema","removeSchema"],"sources":["/core/src/validate.js"],"sourcesContent":["import toPath from \"lodash/toPath\";\nimport Ajv from \"ajv\";\nlet ajv = createAjvInstance();\nimport { deepEquals, getDefaultFormState } from \"./utils\";\n\nlet formerCustomFormats = null;\nlet formerMetaSchema = null;\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\nimport { isObject, mergeObjects } from \"./utils\";\n\nfunction createAjvInstance() {\n  const ajv = new Ajv({\n    errorDataPath: \"property\",\n    allErrors: true,\n    multipleOfPrecision: 8,\n    schemaId: \"auto\",\n    unknownFormats: \"ignore\",\n  });\n\n  // add custom formats\n  ajv.addFormat(\n    \"data-url\",\n    /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/\n  );\n  ajv.addFormat(\n    \"color\",\n    /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/\n  );\n  return ajv;\n}\n\nfunction toErrorSchema(errors) {\n  // Transforms a ajv validation errors list:\n  // [\n  //   {property: \".level1.level2[2].level3\", message: \"err a\"},\n  //   {property: \".level1.level2[2].level3\", message: \"err b\"},\n  //   {property: \".level1.level2[4].level3\", message: \"err b\"},\n  // ]\n  // Into an error tree:\n  // {\n  //   level1: {\n  //     level2: {\n  //       2: {level3: {errors: [\"err a\", \"err b\"]}},\n  //       4: {level3: {errors: [\"err b\"]}},\n  //     }\n  //   }\n  // };\n  if (!errors.length) {\n    return {};\n  }\n  return errors.reduce((errorSchema, error) => {\n    const { property, message } = error;\n    const path = toPath(property);\n    let parent = errorSchema;\n\n    // If the property is at the root (.level1) then toPath creates\n    // an empty array element at the first index. Remove it.\n    if (path.length > 0 && path[0] === \"\") {\n      path.splice(0, 1);\n    }\n\n    for (const segment of path.slice(0)) {\n      if (!(segment in parent)) {\n        parent[segment] = {};\n      }\n      parent = parent[segment];\n    }\n\n    if (Array.isArray(parent.__errors)) {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // \"errors\" (see `validate.createErrorHandler`).\n      parent.__errors = parent.__errors.concat(message);\n    } else {\n      if (message) {\n        parent.__errors = [message];\n      }\n    }\n    return errorSchema;\n  }, {});\n}\n\nexport function toErrorList(errorSchema, fieldName = \"root\") {\n  // XXX: We should transform fieldName as a full field path string.\n  let errorList = [];\n  if (\"__errors\" in errorSchema) {\n    errorList = errorList.concat(\n      errorSchema.__errors.map(stack => {\n        return {\n          stack: `${fieldName}: ${stack}`,\n        };\n      })\n    );\n  }\n  return Object.keys(errorSchema).reduce((acc, key) => {\n    if (key !== \"__errors\") {\n      acc = acc.concat(toErrorList(errorSchema[key], key));\n    }\n    return acc;\n  }, errorList);\n}\n\nfunction createErrorHandler(formData) {\n  const handler = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // \"errors\" (see `utils.toErrorSchema`).\n    __errors: [],\n    addError(message) {\n      this.__errors.push(message);\n    },\n  };\n  if (isObject(formData)) {\n    return Object.keys(formData).reduce((acc, key) => {\n      return { ...acc, [key]: createErrorHandler(formData[key]) };\n    }, handler);\n  }\n  if (Array.isArray(formData)) {\n    return formData.reduce((acc, value, key) => {\n      return { ...acc, [key]: createErrorHandler(value) };\n    }, handler);\n  }\n  return handler;\n}\n\nfunction unwrapErrorHandler(errorHandler) {\n  return Object.keys(errorHandler).reduce((acc, key) => {\n    if (key === \"addError\") {\n      return acc;\n    } else if (key === \"__errors\") {\n      return { ...acc, [key]: errorHandler[key] };\n    }\n    return { ...acc, [key]: unwrapErrorHandler(errorHandler[key]) };\n  }, {});\n}\n\n/**\n * Transforming the error output from ajv to format used by jsonschema.\n * At some point, components should be updated to support ajv.\n */\nfunction transformAjvErrors(errors = []) {\n  if (errors === null) {\n    return [];\n  }\n\n  return errors.map(e => {\n    const { dataPath, keyword, message, params, schemaPath } = e;\n    let property = `${dataPath}`;\n\n    // put data in expected format\n    return {\n      name: keyword,\n      property,\n      message,\n      params, // specific to ajv\n      stack: `${property} ${message}`.trim(),\n      schemaPath,\n    };\n  });\n}\n\n/**\n * This function processes the formData with a user `validate` contributed\n * function, which receives the form data and an `errorHandler` object that\n * will be used to add custom validation errors for each field.\n */\nexport default function validateFormData(\n  formData,\n  schema,\n  customValidate,\n  transformErrors,\n  additionalMetaSchemas = [],\n  customFormats = {}\n) {\n  // Include form data with undefined values, which is required for validation.\n  const rootSchema = schema;\n  formData = getDefaultFormState(schema, formData, rootSchema, true);\n\n  const newMetaSchemas = !deepEquals(formerMetaSchema, additionalMetaSchemas);\n  const newFormats = !deepEquals(formerCustomFormats, customFormats);\n\n  if (newMetaSchemas || newFormats) {\n    ajv = createAjvInstance();\n  }\n\n  // add more schemas to validate against\n  if (\n    additionalMetaSchemas &&\n    newMetaSchemas &&\n    Array.isArray(additionalMetaSchemas)\n  ) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n    formerMetaSchema = additionalMetaSchemas;\n  }\n\n  // add more custom formats to validate against\n  if (customFormats && newFormats && isObject(customFormats)) {\n    Object.keys(customFormats).forEach(formatName => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n\n    formerCustomFormats = customFormats;\n  }\n\n  let validationError = null;\n  try {\n    ajv.validate(schema, formData);\n  } catch (err) {\n    validationError = err;\n  }\n\n  let errors = transformAjvErrors(ajv.errors);\n  // Clear errors to prevent persistent errors, see #1104\n\n  ajv.errors = null;\n\n  const noProperMetaSchema =\n    validationError &&\n    validationError.message &&\n    typeof validationError.message === \"string\" &&\n    validationError.message.includes(\"no schema with key or ref \");\n\n  if (noProperMetaSchema) {\n    errors = [\n      ...errors,\n      {\n        stack: validationError.message,\n      },\n    ];\n  }\n  if (typeof transformErrors === \"function\") {\n    errors = transformErrors(errors);\n  }\n\n  let errorSchema = toErrorSchema(errors);\n\n  if (noProperMetaSchema) {\n    errorSchema = {\n      ...errorSchema,\n      ...{\n        $schema: {\n          __errors: [validationError.message],\n        },\n      },\n    };\n  }\n\n  if (typeof customValidate !== \"function\") {\n    return { errors, errorSchema };\n  }\n\n  const errorHandler = customValidate(formData, createErrorHandler(formData));\n  const userErrorSchema = unwrapErrorHandler(errorHandler);\n  const newErrorSchema = mergeObjects(errorSchema, userErrorSchema, true);\n  // XXX: The errors list produced is not fully compliant with the format\n  // exposed by the jsonschema lib, which contains full field paths and other\n  // properties.\n  const newErrors = toErrorList(newErrorSchema);\n\n  return {\n    errors: newErrors,\n    errorSchema: newErrorSchema,\n  };\n}\n\n/**\n * Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n * This is used in isValid to make references to the rootSchema\n */\nexport function withIdRefPrefix(schemaNode) {\n  let obj = schemaNode;\n  if (schemaNode.constructor === Object) {\n    obj = { ...schemaNode };\n    for (const key in obj) {\n      const value = obj[key];\n      if (\n        key === \"$ref\" &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        obj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        obj[key] = withIdRefPrefix(value);\n      }\n    }\n  } else if (Array.isArray(schemaNode)) {\n    obj = [...schemaNode];\n    for (var i = 0; i < obj.length; i++) {\n      obj[i] = withIdRefPrefix(obj[i]);\n    }\n  }\n  return obj;\n}\n\n/**\n * Validates data against a schema, returning true if the data is valid, or\n * false otherwise. If the schema is invalid, then this function will return\n * false.\n */\nexport function isValid(schema, data, rootSchema) {\n  try {\n    // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n    // then rewrite the schema ref's to point to the rootSchema\n    // this accounts for the case where schema have references to models\n    // that lives in the rootSchema but not in the schema in question.\n    return ajv\n      .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n      .validate(withIdRefPrefix(schema), data);\n  } catch (e) {\n    return false;\n  } finally {\n    // make sure we remove the rootSchema from the global ajv instance\n    ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}