{"ast":null,"code":"var cloneDeep = require('lodash/cloneDeep');\n\nvar compare = require('json-schema-compare');\n\nvar computeLcm = require('compute-lcm');\n\nvar defaultsDeep = require('lodash/defaultsDeep');\n\nvar flatten = require('lodash/flatten');\n\nvar flattenDeep = require('lodash/flattenDeep');\n\nvar intersection = require('lodash/intersection');\n\nvar intersectionWith = require('lodash/intersectionWith');\n\nvar isEqual = require('lodash/isEqual');\n\nvar isPlainObject = require('lodash/isPlainObject');\n\nvar pullAll = require('lodash/pullAll');\n\nvar sortBy = require('lodash/sortBy');\n\nvar forEach = require('lodash/forEach');\n\nvar uniq = require('lodash/uniq');\n\nvar uniqWith = require('lodash/uniqWith');\n\nvar without = require('lodash/without');\n\nvar withoutArr = function (arr) {\n  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    rest[_key - 1] = arguments[_key];\n  }\n\n  return without.apply(null, [arr].concat(flatten(rest)));\n};\n\nvar isPropertyRelated = key => contains(propertyRelated, key);\n\nvar isItemsRelated = key => contains(itemsRelated, key);\n\nvar contains = (arr, val) => arr.indexOf(val) !== -1;\n\nvar isEmptySchema = obj => !keys(obj).length && obj !== false && obj !== true;\n\nvar isSchema = val => isPlainObject(val) || val === true || val === false;\n\nvar isFalse = val => val === false;\n\nvar isTrue = val => val === true;\n\nvar schemaResolver = (compacted, key, mergeSchemas) => mergeSchemas(compacted);\n\nvar stringArray = values => sortBy(uniq(flattenDeep(values)));\n\nvar notUndefined = val => val !== undefined;\n\nvar allUniqueKeys = arr => uniq(flattenDeep(arr.map(keys))); // resolvers\n\n\nvar first = compacted => compacted[0];\n\nvar required = compacted => stringArray(compacted);\n\nvar maximumValue = compacted => Math.max.apply(Math, compacted);\n\nvar minimumValue = compacted => Math.min.apply(Math, compacted);\n\nvar uniqueItems = compacted => compacted.some(isTrue);\n\nvar examples = compacted => uniqWith(flatten(compacted), isEqual);\n\nfunction compareProp(key) {\n  return function (a, b) {\n    return compare({\n      [key]: a\n    }, {\n      [key]: b\n    });\n  };\n}\n\nfunction getAllOf(schema) {\n  if (Array.isArray(schema.allOf)) {\n    var allOf = schema.allOf;\n    delete schema.allOf;\n    return [schema].concat(allOf.map(function (allSchema) {\n      return getAllOf(allSchema);\n    }));\n  } else {\n    return [schema];\n  }\n}\n\nfunction getValues(schemas, key) {\n  return schemas.map(function (schema) {\n    return schema && schema[key];\n  });\n}\n\nfunction getItemSchemas(subSchemas, key) {\n  return subSchemas.map(function (sub) {\n    if (!sub) {\n      return;\n    }\n\n    if (Array.isArray(sub.items)) {\n      var schemaAtPos = sub.items[key];\n\n      if (isSchema(schemaAtPos)) {\n        return schemaAtPos;\n      } else if (sub.hasOwnProperty('additionalItems')) {\n        return sub.additionalItems;\n      }\n    } else {\n      return sub.items;\n    }\n  });\n}\n\nfunction tryMergeSchemaGroups(schemaGroups, mergeSchemas) {\n  return schemaGroups.map(function (schemas, index) {\n    try {\n      return mergeSchemas(schemas, index);\n    } catch (e) {\n      return undefined;\n    }\n  }).filter(notUndefined);\n}\n\nfunction getAdditionalSchemas(subSchemas) {\n  return subSchemas.map(function (sub) {\n    if (!sub) {\n      return;\n    }\n\n    if (Array.isArray(sub.items)) {\n      return sub.additionalItems;\n    }\n\n    return sub.items;\n  });\n}\n\nfunction keys(obj) {\n  if (isPlainObject(obj) || Array.isArray(obj)) {\n    return Object.keys(obj);\n  } else {\n    return [];\n  }\n}\n\nfunction getAnyOfCombinations(arrOfArrays, combinations) {\n  combinations = combinations || [];\n\n  if (!arrOfArrays.length) {\n    return combinations;\n  }\n\n  var values = arrOfArrays.slice(0).shift();\n  var rest = arrOfArrays.slice(1);\n\n  if (combinations.length) {\n    return getAnyOfCombinations(rest, flatten(combinations.map(combination => values.map(item => [item].concat(combination)))));\n  }\n\n  return getAnyOfCombinations(rest, values.map(item => item));\n}\n\nfunction mergeWithArray(base, newItems) {\n  if (Array.isArray(base)) {\n    base.splice.apply(base, [0, 0].concat(newItems));\n    return base;\n  } else {\n    return newItems;\n  }\n}\n\nfunction throwIncompatible(values, paths) {\n  var asJSON;\n\n  try {\n    asJSON = values.map(function (val) {\n      return JSON.stringify(val, null, 2);\n    }).join('\\n');\n  } catch (variable) {\n    asJSON = values.join(', ');\n  }\n\n  throw new Error('Could not resolve values for path:\"' + paths.join('.') + '\". They are probably incompatible. Values: \\n' + asJSON);\n}\n\nfunction cleanupReturnValue(returnObject) {\n  // cleanup empty\n  for (var prop in returnObject) {\n    if (returnObject.hasOwnProperty(prop) && isEmptySchema(returnObject[prop])) {\n      delete returnObject[prop];\n    }\n  }\n\n  return returnObject;\n}\n\nfunction createRequiredSubMerger(mergeSchemas, key, parents) {\n  return function (schemas, subKey) {\n    if (subKey === undefined) {\n      throw new Error('You need to call merger with a key for the property name or index if array.');\n    }\n\n    subKey = String(subKey);\n    return mergeSchemas(schemas, null, parents.concat(key, subKey));\n  };\n}\n\nfunction callGroupResolver(keys, resolverName, schemas, mergeSchemas, options, parents) {\n  if (keys.length) {\n    var resolver = options.resolvers[resolverName];\n\n    if (!resolver) {\n      throw new Error('No resolver found for ' + resolverName);\n    }\n\n    var compacted = uniqWith(schemas.map(function (schema) {\n      return keys.reduce(function (all, key) {\n        if (schema[key] !== undefined) {\n          all[key] = schema[key];\n        }\n\n        return all;\n      }, {});\n    }).filter(notUndefined), compare);\n    var related = resolverName === 'properties' ? propertyRelated : itemsRelated;\n    var mergers = related.reduce(function (all, key) {\n      if (contains(schemaGroupProps, key)) {\n        all[key] = createRequiredSubMerger(mergeSchemas, key, parents);\n      } else {\n        all[key] = function (schemas) {\n          return mergeSchemas(schemas, null, parents.concat(key));\n        };\n      }\n\n      return all;\n    }, {});\n\n    if (resolverName === 'items') {\n      mergers.itemsArray = createRequiredSubMerger(mergeSchemas, 'items', parents);\n\n      mergers.items = function (schemas) {\n        return mergeSchemas(schemas, null, parents.concat('items'));\n      };\n    }\n\n    var result = resolver(compacted, parents.concat(resolverName), mergers, options);\n\n    if (!isPlainObject(result)) {\n      throwIncompatible(compacted, parents.concat(resolverName));\n    }\n\n    return cleanupReturnValue(result);\n  }\n} // Provide source when array\n\n\nfunction mergeSchemaGroup(group, mergeSchemas, source) {\n  var allKeys = allUniqueKeys(source || group);\n  var extractor = source ? getItemSchemas : getValues;\n  return allKeys.reduce(function (all, key) {\n    var schemas = extractor(group, key);\n    var compacted = uniqWith(schemas.filter(notUndefined), compare);\n    all[key] = mergeSchemas(compacted, key);\n    return all;\n  }, source ? [] : {});\n}\n\nfunction removeFalseSchemas(target) {\n  forEach(target, function (schema, prop) {\n    if (schema === false) {\n      delete target[prop];\n    }\n  });\n}\n\nfunction removeFalseSchemasFromArray(target) {\n  forEach(target, function (schema, index) {\n    if (schema === false) {\n      target.splice(index, 1);\n    }\n  });\n}\n\nfunction createRequiredMetaArray(arr) {\n  return {\n    required: arr\n  };\n}\n\nvar propertyRelated = ['properties', 'patternProperties', 'additionalProperties'];\nvar itemsRelated = ['items', 'additionalItems'];\nvar schemaGroupProps = ['properties', 'patternProperties', 'definitions', 'dependencies'];\nvar schemaArrays = ['anyOf', 'oneOf'];\nvar schemaProps = ['additionalProperties', 'additionalItems', 'contains', 'propertyNames', 'not', 'items'];\nvar defaultResolvers = {\n  type(compacted) {\n    if (compacted.some(Array.isArray)) {\n      var normalized = compacted.map(function (val) {\n        return Array.isArray(val) ? val : [val];\n      });\n      var common = intersection.apply(null, normalized);\n\n      if (common.length === 1) {\n        return common[0];\n      } else if (common.length > 1) {\n        return uniq(common);\n      }\n    }\n  },\n\n  properties(values, key, mergers, options) {\n    // first get rid of all non permitted properties\n    if (!options.ignoreAdditionalProperties) {\n      values.forEach(function (subSchema) {\n        var otherSubSchemas = values.filter(s => s !== subSchema);\n        var ownKeys = keys(subSchema.properties);\n        var ownPatternKeys = keys(subSchema.patternProperties);\n        var ownPatterns = ownPatternKeys.map(k => new RegExp(k));\n        otherSubSchemas.forEach(function (other) {\n          var allOtherKeys = keys(other.properties);\n          var keysMatchingPattern = allOtherKeys.filter(k => ownPatterns.some(pk => pk.test(k)));\n          var additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern);\n          additionalKeys.forEach(function (key) {\n            other.properties[key] = mergers.properties([other.properties[key], subSchema.additionalProperties], key);\n          });\n        });\n      }); // remove disallowed patternProperties\n\n      values.forEach(function (subSchema) {\n        var otherSubSchemas = values.filter(s => s !== subSchema);\n        var ownPatternKeys = keys(subSchema.patternProperties);\n\n        if (subSchema.additionalProperties === false) {\n          otherSubSchemas.forEach(function (other) {\n            var allOtherPatterns = keys(other.patternProperties);\n            var additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys);\n            additionalPatternKeys.forEach(key => delete other.patternProperties[key]);\n          });\n        }\n      });\n    }\n\n    var returnObject = {\n      additionalProperties: mergers.additionalProperties(values.map(s => s.additionalProperties)),\n      patternProperties: mergeSchemaGroup(values.map(s => s.patternProperties), mergers.patternProperties),\n      properties: mergeSchemaGroup(values.map(s => s.properties), mergers.properties)\n    };\n\n    if (returnObject.additionalProperties === false) {\n      removeFalseSchemas(returnObject.properties);\n    }\n\n    return returnObject;\n  },\n\n  dependencies(compacted, paths, mergeSchemas) {\n    var allChildren = allUniqueKeys(compacted);\n    return allChildren.reduce(function (all, childKey) {\n      var childSchemas = getValues(compacted, childKey);\n      var innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual); // to support dependencies\n\n      var innerArrays = innerCompacted.filter(Array.isArray);\n\n      if (innerArrays.length) {\n        if (innerArrays.length === innerCompacted.length) {\n          all[childKey] = stringArray(innerCompacted);\n        } else {\n          var innerSchemas = innerCompacted.filter(isSchema);\n          var arrayMetaScheams = innerArrays.map(createRequiredMetaArray);\n          all[childKey] = mergeSchemas(innerSchemas.concat(arrayMetaScheams), childKey);\n        }\n\n        return all;\n      }\n\n      innerCompacted = uniqWith(innerCompacted, compare);\n      all[childKey] = mergeSchemas(innerCompacted, childKey);\n      return all;\n    }, {});\n  },\n\n  items(values, paths, mergers) {\n    var items = values.map(s => s.items);\n    var itemsCompacted = items.filter(notUndefined);\n    var returnObject = {};\n\n    if (itemsCompacted.every(isSchema)) {\n      returnObject.items = mergers.items(items);\n    } else {\n      returnObject.items = mergeSchemaGroup(values, mergers.itemsArray, items);\n    }\n\n    var schemasAtLastPos;\n\n    if (itemsCompacted.every(Array.isArray)) {\n      schemasAtLastPos = values.map(s => s.additionalItems);\n    } else if (itemsCompacted.some(Array.isArray)) {\n      schemasAtLastPos = getAdditionalSchemas(values);\n    }\n\n    if (schemasAtLastPos) {\n      returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos);\n    }\n\n    if (returnObject.additionalItems === false && Array.isArray(returnObject.items)) {\n      removeFalseSchemasFromArray(returnObject.items);\n    }\n\n    return returnObject;\n  },\n\n  oneOf(compacted, paths, mergeSchemas) {\n    var combinations = getAnyOfCombinations(cloneDeep(compacted));\n    var result = tryMergeSchemaGroups(combinations, mergeSchemas);\n    var unique = uniqWith(result, compare);\n\n    if (unique.length) {\n      return unique;\n    }\n  },\n\n  not(compacted) {\n    return {\n      anyOf: compacted\n    };\n  },\n\n  pattern(compacted, paths, mergeSchemas, options, reportUnresolved) {\n    var key = paths.pop();\n    reportUnresolved(compacted.map(function (regexp) {\n      return {\n        [key]: regexp\n      };\n    }));\n  },\n\n  multipleOf(compacted) {\n    var integers = compacted.slice(0);\n    var factor = 1;\n\n    while (integers.some(n => !Number.isInteger(n))) {\n      integers = integers.map(n => n * 10);\n      factor = factor * 10;\n    }\n\n    return computeLcm(integers) / factor;\n  },\n\n  enum(compacted) {\n    var enums = intersectionWith.apply(null, compacted.concat(isEqual));\n\n    if (enums.length) {\n      return sortBy(enums);\n    }\n  }\n\n};\ndefaultResolvers.$id = first;\ndefaultResolvers.$ref = first;\ndefaultResolvers.$schema = first;\ndefaultResolvers.additionalItems = schemaResolver;\ndefaultResolvers.additionalProperties = schemaResolver;\ndefaultResolvers.anyOf = defaultResolvers.oneOf;\ndefaultResolvers.contains = schemaResolver;\ndefaultResolvers.default = first;\ndefaultResolvers.definitions = defaultResolvers.dependencies;\ndefaultResolvers.description = first;\ndefaultResolvers.examples = examples;\ndefaultResolvers.exclusiveMaximum = minimumValue;\ndefaultResolvers.exclusiveMinimum = maximumValue;\ndefaultResolvers.maximum = minimumValue;\ndefaultResolvers.maxItems = minimumValue;\ndefaultResolvers.maxLength = minimumValue;\ndefaultResolvers.maxProperties = minimumValue;\ndefaultResolvers.minimum = maximumValue;\ndefaultResolvers.minItems = maximumValue;\ndefaultResolvers.minLength = maximumValue;\ndefaultResolvers.minProperties = maximumValue;\ndefaultResolvers.propertyNames = schemaResolver;\ndefaultResolvers.required = required;\ndefaultResolvers.title = first;\ndefaultResolvers.uniqueItems = uniqueItems;\n\nfunction merger(rootSchema, options, totalSchemas) {\n  totalSchemas = totalSchemas || [];\n  options = defaultsDeep(options, {\n    ignoreAdditionalProperties: false,\n    resolvers: defaultResolvers\n  });\n\n  function mergeSchemas(schemas, base, parents) {\n    schemas = cloneDeep(schemas.filter(notUndefined));\n    parents = parents || [];\n    var merged = isPlainObject(base) ? base : {}; // return undefined, an empty schema\n\n    if (!schemas.length) {\n      return;\n    }\n\n    if (schemas.some(isFalse)) {\n      return false;\n    }\n\n    if (schemas.every(isTrue)) {\n      return true;\n    } // there are no false and we don't need the true ones as they accept everything\n\n\n    schemas = schemas.filter(isPlainObject);\n    var allKeys = allUniqueKeys(schemas);\n\n    if (contains(allKeys, 'allOf')) {\n      return merger({\n        allOf: schemas\n      }, options, totalSchemas);\n    }\n\n    var propertyKeys = allKeys.filter(isPropertyRelated);\n    pullAll(allKeys, propertyKeys);\n    var itemKeys = allKeys.filter(isItemsRelated);\n    pullAll(allKeys, itemKeys);\n    allKeys.forEach(function (key) {\n      var values = getValues(schemas, key);\n      var compacted = uniqWith(values.filter(notUndefined), compareProp(key)); // arrayprops like anyOf and oneOf must be merged first, as they contains schemas\n      // allOf is treated differently alltogether\n\n      if (compacted.length === 1 && contains(schemaArrays, key)) {\n        merged[key] = compacted[0].map(function (schema) {\n          return mergeSchemas([schema], schema);\n        }); // prop groups must always be resolved\n      } else if (compacted.length === 1 && !contains(schemaGroupProps, key) && !contains(schemaProps, key)) {\n        merged[key] = compacted[0];\n      } else {\n        var resolver = options.resolvers[key] || options.resolvers.defaultResolver;\n\n        if (!resolver) {\n          throw new Error('No resolver found for key ' + key + '. You can provide a resolver for this keyword in the options, or provide a default resolver.');\n        }\n\n        var merger; // get custom merger for groups\n\n        if (contains(schemaGroupProps, key) || contains(schemaArrays, key)) {\n          merger = createRequiredSubMerger(mergeSchemas, key, parents);\n        } else {\n          merger = function (schemas) {\n            return mergeSchemas(schemas, null, parents.concat(key));\n          };\n        }\n\n        var calledWithArray = false;\n        merged[key] = resolver(compacted, parents.concat(key), merger, options, function (unresolvedSchemas) {\n          calledWithArray = Array.isArray(unresolvedSchemas);\n          return addToAllOf(unresolvedSchemas);\n        });\n\n        if (merged[key] === undefined && !calledWithArray) {\n          throwIncompatible(compacted, parents.concat(key));\n        } else if (merged[key] === undefined) {\n          delete merged[key];\n        }\n      }\n    });\n    Object.assign(merged, callGroupResolver(propertyKeys, 'properties', schemas, mergeSchemas, options, parents));\n    Object.assign(merged, callGroupResolver(itemKeys, 'items', schemas, mergeSchemas, options, parents));\n\n    function addToAllOf(unresolvedSchemas) {\n      merged.allOf = mergeWithArray(merged.allOf, unresolvedSchemas);\n    }\n\n    return merged;\n  }\n\n  var allSchemas = flattenDeep(getAllOf(rootSchema));\n  var merged = mergeSchemas(allSchemas, rootSchema);\n  return merged;\n}\n\nmerger.options = {\n  resolvers: defaultResolvers\n};\nmodule.exports = merger;","map":{"version":3,"sources":["/home/testvmuser/kitt4sme-digitaldatasheets/node_modules/json-schema-merge-allof/src/index.js"],"names":["cloneDeep","require","compare","computeLcm","defaultsDeep","flatten","flattenDeep","intersection","intersectionWith","isEqual","isPlainObject","pullAll","sortBy","forEach","uniq","uniqWith","without","withoutArr","arr","rest","apply","concat","isPropertyRelated","key","contains","propertyRelated","isItemsRelated","itemsRelated","val","indexOf","isEmptySchema","obj","keys","length","isSchema","isFalse","isTrue","schemaResolver","compacted","mergeSchemas","stringArray","values","notUndefined","undefined","allUniqueKeys","map","first","required","maximumValue","Math","max","minimumValue","min","uniqueItems","some","examples","compareProp","a","b","getAllOf","schema","Array","isArray","allOf","allSchema","getValues","schemas","getItemSchemas","subSchemas","sub","items","schemaAtPos","hasOwnProperty","additionalItems","tryMergeSchemaGroups","schemaGroups","index","e","filter","getAdditionalSchemas","Object","getAnyOfCombinations","arrOfArrays","combinations","slice","shift","combination","item","mergeWithArray","base","newItems","splice","throwIncompatible","paths","asJSON","JSON","stringify","join","variable","Error","cleanupReturnValue","returnObject","prop","createRequiredSubMerger","parents","subKey","String","callGroupResolver","resolverName","options","resolver","resolvers","reduce","all","related","mergers","schemaGroupProps","itemsArray","result","mergeSchemaGroup","group","source","allKeys","extractor","removeFalseSchemas","target","removeFalseSchemasFromArray","createRequiredMetaArray","schemaArrays","schemaProps","defaultResolvers","type","normalized","common","properties","ignoreAdditionalProperties","subSchema","otherSubSchemas","s","ownKeys","ownPatternKeys","patternProperties","ownPatterns","k","RegExp","other","allOtherKeys","keysMatchingPattern","pk","test","additionalKeys","additionalProperties","allOtherPatterns","additionalPatternKeys","dependencies","allChildren","childKey","childSchemas","innerCompacted","innerArrays","innerSchemas","arrayMetaScheams","itemsCompacted","every","schemasAtLastPos","oneOf","unique","not","anyOf","pattern","reportUnresolved","pop","regexp","multipleOf","integers","factor","n","Number","isInteger","enum","enums","$id","$ref","$schema","default","definitions","description","exclusiveMaximum","exclusiveMinimum","maximum","maxItems","maxLength","maxProperties","minimum","minItems","minLength","minProperties","propertyNames","title","merger","rootSchema","totalSchemas","merged","propertyKeys","itemKeys","defaultResolver","calledWithArray","unresolvedSchemas","addToAllOf","assign","allSchemas","module","exports"],"mappings":"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","sourcesContent":["var cloneDeep = require('lodash/cloneDeep')\nvar compare = require('json-schema-compare')\nvar computeLcm = require('compute-lcm')\nvar defaultsDeep = require('lodash/defaultsDeep')\nvar flatten = require('lodash/flatten')\nvar flattenDeep = require('lodash/flattenDeep')\nvar intersection = require('lodash/intersection')\nvar intersectionWith = require('lodash/intersectionWith')\nvar isEqual = require('lodash/isEqual')\nvar isPlainObject = require('lodash/isPlainObject')\nvar pullAll = require('lodash/pullAll')\nvar sortBy = require('lodash/sortBy')\nvar forEach = require('lodash/forEach')\nvar uniq = require('lodash/uniq')\nvar uniqWith = require('lodash/uniqWith')\nvar without = require('lodash/without')\n\nvar withoutArr = (arr, ...rest) => without.apply(null, [arr].concat(flatten(rest)))\nvar isPropertyRelated = (key) => contains(propertyRelated, key)\nvar isItemsRelated = (key) => contains(itemsRelated, key)\nvar contains = (arr, val) => arr.indexOf(val) !== -1\nvar isEmptySchema = (obj) => (!keys(obj).length) && obj !== false && obj !== true\nvar isSchema = (val) => isPlainObject(val) || val === true || val === false\nvar isFalse = (val) => val === false\nvar isTrue = (val) => val === true\nvar schemaResolver = (compacted, key, mergeSchemas) => mergeSchemas(compacted)\nvar stringArray = (values) => sortBy(uniq(flattenDeep(values)))\nvar notUndefined = (val) => val !== undefined\nvar allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)))\n\n// resolvers\nvar first = compacted => compacted[0]\nvar required = compacted => stringArray(compacted)\nvar maximumValue = compacted => Math.max.apply(Math, compacted)\nvar minimumValue = compacted => Math.min.apply(Math, compacted)\nvar uniqueItems = compacted => compacted.some(isTrue)\nvar examples = compacted => uniqWith(flatten(compacted), isEqual)\n\nfunction compareProp(key) {\n  return function(a, b) {\n    return compare({\n      [key]: a\n    }, {[key]: b})\n  }\n}\n\nfunction getAllOf(schema) {\n  if (Array.isArray(schema.allOf)) {\n    var allOf = schema.allOf\n    delete schema.allOf\n    return [schema].concat(allOf.map(function(allSchema) {\n      return getAllOf(allSchema)\n    }))\n  } else {\n    return [schema]\n  }\n}\n\nfunction getValues(schemas, key) {\n  return schemas.map(function(schema) {\n    return schema && schema[key]\n  })\n}\n\nfunction getItemSchemas(subSchemas, key) {\n  return subSchemas.map(function(sub) {\n    if (!sub) {\n      return\n    }\n\n    if (Array.isArray(sub.items)) {\n      var schemaAtPos = sub.items[key]\n      if (isSchema(schemaAtPos)) {\n        return schemaAtPos\n      } else if (sub.hasOwnProperty('additionalItems')) {\n        return sub.additionalItems\n      }\n    } else {\n      return sub.items\n    }\n  })\n}\n\nfunction tryMergeSchemaGroups(schemaGroups, mergeSchemas) {\n  return schemaGroups.map(function(schemas, index) {\n    try {\n      return mergeSchemas(schemas, index)\n    } catch (e) {\n      return undefined\n    }\n  }).filter(notUndefined)\n}\n\nfunction getAdditionalSchemas(subSchemas) {\n  return subSchemas.map(function(sub) {\n    if (!sub) {\n      return\n    }\n    if (Array.isArray(sub.items)) {\n      return sub.additionalItems\n    }\n    return sub.items\n  })\n}\n\nfunction keys(obj) {\n  if (isPlainObject(obj) || Array.isArray(obj)) {\n    return Object.keys(obj)\n  } else {\n    return []\n  }\n}\n\nfunction getAnyOfCombinations(arrOfArrays, combinations) {\n  combinations = combinations || []\n  if (!arrOfArrays.length) {\n    return combinations\n  }\n\n  var values = arrOfArrays.slice(0).shift()\n  var rest = arrOfArrays.slice(1)\n  if (combinations.length) {\n    return getAnyOfCombinations(rest, flatten(combinations.map(combination => values.map(item => ([item].concat(combination))))))\n  }\n  return getAnyOfCombinations(rest, values.map(item => (item)))\n}\n\nfunction mergeWithArray(base, newItems) {\n  if (Array.isArray(base)) {\n    base.splice.apply(base, [0, 0].concat(newItems))\n    return base\n  } else {\n    return newItems\n  }\n}\n\nfunction throwIncompatible(values, paths) {\n  var asJSON\n  try {\n    asJSON = values.map(function(val) {\n      return JSON.stringify(val, null, 2)\n    }).join('\\n')\n  } catch (variable) {\n    asJSON = values.join(', ')\n  }\n  throw new Error('Could not resolve values for path:\"' + paths.join('.') + '\". They are probably incompatible. Values: \\n' + asJSON)\n}\n\nfunction cleanupReturnValue(returnObject) {\n  // cleanup empty\n  for (var prop in returnObject) {\n    if (returnObject.hasOwnProperty(prop) && isEmptySchema(returnObject[prop])) {\n      delete returnObject[prop]\n    }\n  }\n  return returnObject\n}\n\nfunction createRequiredSubMerger(mergeSchemas, key, parents) {\n  return function(schemas, subKey) {\n    if (subKey === undefined) {\n      throw new Error('You need to call merger with a key for the property name or index if array.')\n    }\n    subKey = String(subKey)\n    return mergeSchemas(schemas, null, parents.concat(key, subKey))\n  }\n}\n\nfunction callGroupResolver(keys, resolverName, schemas, mergeSchemas, options, parents) {\n  if (keys.length) {\n    var resolver = options.resolvers[resolverName]\n    if (!resolver) {\n      throw new Error('No resolver found for ' + resolverName)\n    }\n\n    var compacted = uniqWith(schemas.map(function(schema) {\n      return keys.reduce(function(all, key) {\n        if (schema[key] !== undefined) {\n          all[key] = schema[key]\n        }\n        return all\n      }, {})\n    }).filter(notUndefined), compare)\n\n    var related = resolverName === 'properties'\n      ? propertyRelated\n      : itemsRelated\n\n    var mergers = related.reduce(function(all, key) {\n      if (contains(schemaGroupProps, key)) {\n        all[key] = createRequiredSubMerger(mergeSchemas, key, parents)\n      } else {\n        all[key] = function(schemas) {\n          return mergeSchemas(schemas, null, parents.concat(key))\n        }\n      }\n      return all\n    }, {})\n\n    if (resolverName === 'items') {\n      mergers.itemsArray = createRequiredSubMerger(mergeSchemas, 'items', parents)\n      mergers.items = function(schemas) {\n        return mergeSchemas(schemas, null, parents.concat('items'))\n      }\n    }\n\n    var result = resolver(compacted, parents.concat(resolverName), mergers, options)\n\n    if (!isPlainObject(result)) {\n      throwIncompatible(compacted, parents.concat(resolverName))\n    }\n\n    return cleanupReturnValue(result)\n  }\n}\n\n// Provide source when array\nfunction mergeSchemaGroup(group, mergeSchemas, source) {\n  var allKeys = allUniqueKeys(source || group)\n  var extractor = source\n    ? getItemSchemas\n    : getValues\n  return allKeys.reduce(function(all, key) {\n    var schemas = extractor(group, key)\n    var compacted = uniqWith(schemas.filter(notUndefined), compare)\n    all[key] = mergeSchemas(compacted, key)\n    return all\n  }, source\n    ? []\n    : {})\n}\n\nfunction removeFalseSchemas(target) {\n  forEach(target, function(schema, prop) {\n    if (schema === false) {\n      delete target[prop]\n    }\n  })\n}\n\nfunction removeFalseSchemasFromArray(target) {\n  forEach(target, function(schema, index) {\n    if (schema === false) {\n      target.splice(index, 1)\n    }\n  })\n}\n\nfunction createRequiredMetaArray(arr) {\n  return {required: arr}\n}\n\nvar propertyRelated = ['properties', 'patternProperties', 'additionalProperties']\nvar itemsRelated = ['items', 'additionalItems']\nvar schemaGroupProps = ['properties', 'patternProperties', 'definitions', 'dependencies']\nvar schemaArrays = ['anyOf', 'oneOf']\nvar schemaProps = [\n  'additionalProperties',\n  'additionalItems',\n  'contains',\n  'propertyNames',\n  'not',\n  'items'\n]\n\nvar defaultResolvers = {\n  type(compacted) {\n    if (compacted.some(Array.isArray)) {\n      var normalized = compacted.map(function(val) {\n        return Array.isArray(val)\n          ? val\n          : [val]\n      })\n      var common = intersection.apply(null, normalized)\n\n      if (common.length === 1) {\n        return common[0]\n      } else if (common.length > 1) {\n        return uniq(common)\n      }\n    }\n  },\n  properties(values, key, mergers, options) {\n    // first get rid of all non permitted properties\n    if (!options.ignoreAdditionalProperties) {\n      values.forEach(function(subSchema) {\n        var otherSubSchemas = values.filter(s => s !== subSchema)\n        var ownKeys = keys(subSchema.properties)\n        var ownPatternKeys = keys(subSchema.patternProperties)\n        var ownPatterns = ownPatternKeys.map(k => new RegExp(k))\n        otherSubSchemas.forEach(function(other) {\n          var allOtherKeys = keys(other.properties)\n          var keysMatchingPattern = allOtherKeys.filter(k => ownPatterns.some(pk => pk.test(k)))\n          var additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern)\n          additionalKeys.forEach(function(key) {\n            other.properties[key] = mergers.properties([\n              other.properties[key], subSchema.additionalProperties\n            ], key)\n          })\n        })\n      })\n\n      // remove disallowed patternProperties\n      values.forEach(function(subSchema) {\n        var otherSubSchemas = values.filter(s => s !== subSchema)\n        var ownPatternKeys = keys(subSchema.patternProperties)\n        if (subSchema.additionalProperties === false) {\n          otherSubSchemas.forEach(function(other) {\n            var allOtherPatterns = keys(other.patternProperties)\n            var additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys)\n            additionalPatternKeys.forEach(key => delete other.patternProperties[key])\n          })\n        }\n      })\n    }\n\n    var returnObject = {\n      additionalProperties: mergers.additionalProperties(values.map(s => s.additionalProperties)),\n      patternProperties: mergeSchemaGroup(values.map(s => s.patternProperties), mergers.patternProperties),\n      properties: mergeSchemaGroup(values.map(s => s.properties), mergers.properties)\n    }\n\n    if (returnObject.additionalProperties === false) {\n      removeFalseSchemas(returnObject.properties)\n    }\n\n    return returnObject\n  },\n  dependencies(compacted, paths, mergeSchemas) {\n    var allChildren = allUniqueKeys(compacted)\n\n    return allChildren.reduce(function(all, childKey) {\n      var childSchemas = getValues(compacted, childKey)\n      var innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual)\n\n      // to support dependencies\n      var innerArrays = innerCompacted.filter(Array.isArray)\n\n      if (innerArrays.length) {\n        if (innerArrays.length === innerCompacted.length) {\n          all[childKey] = stringArray(innerCompacted)\n        } else {\n          var innerSchemas = innerCompacted.filter(isSchema)\n          var arrayMetaScheams = innerArrays.map(createRequiredMetaArray)\n          all[childKey] = mergeSchemas(innerSchemas.concat(arrayMetaScheams), childKey)\n        }\n        return all\n      }\n\n      innerCompacted = uniqWith(innerCompacted, compare)\n\n      all[childKey] = mergeSchemas(innerCompacted, childKey)\n      return all\n    }, {})\n  },\n  items(values, paths, mergers) {\n    var items = values.map(s => s.items)\n    var itemsCompacted = items.filter(notUndefined)\n    var returnObject = {}\n\n    if (itemsCompacted.every(isSchema)) {\n      returnObject.items = mergers.items(items)\n    } else {\n      returnObject.items = mergeSchemaGroup(values, mergers.itemsArray, items)\n    }\n\n    var schemasAtLastPos\n    if (itemsCompacted.every(Array.isArray)) {\n      schemasAtLastPos = values.map(s => s.additionalItems)\n    } else if (itemsCompacted.some(Array.isArray)) {\n      schemasAtLastPos = getAdditionalSchemas(values)\n    }\n\n    if (schemasAtLastPos) {\n      returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos)\n    }\n\n    if (returnObject.additionalItems === false && Array.isArray(returnObject.items)) {\n      removeFalseSchemasFromArray(returnObject.items)\n    }\n\n    return returnObject\n  },\n  oneOf(compacted, paths, mergeSchemas) {\n    var combinations = getAnyOfCombinations(cloneDeep(compacted))\n    var result = tryMergeSchemaGroups(combinations, mergeSchemas)\n    var unique = uniqWith(result, compare)\n\n    if (unique.length) {\n      return unique\n    }\n  },\n  not(compacted) {\n    return {anyOf: compacted}\n  },\n  pattern(compacted, paths, mergeSchemas, options, reportUnresolved) {\n    var key = paths.pop()\n    reportUnresolved(compacted.map(function(regexp) {\n      return {[key]: regexp}\n    }))\n  },\n  multipleOf(compacted) {\n    var integers = compacted.slice(0)\n    var factor = 1\n    while (integers.some(n => !Number.isInteger(n))) {\n      integers = integers.map(n => n * 10)\n      factor = factor * 10\n    }\n    return computeLcm(integers) / factor\n  },\n  enum(compacted) {\n    var enums = intersectionWith.apply(null, compacted.concat(isEqual))\n    if (enums.length) {\n      return sortBy(enums)\n    }\n  }\n}\n\ndefaultResolvers.$id = first\ndefaultResolvers.$ref = first\ndefaultResolvers.$schema = first\ndefaultResolvers.additionalItems = schemaResolver\ndefaultResolvers.additionalProperties = schemaResolver\ndefaultResolvers.anyOf = defaultResolvers.oneOf\ndefaultResolvers.contains = schemaResolver\ndefaultResolvers.default = first\ndefaultResolvers.definitions = defaultResolvers.dependencies\ndefaultResolvers.description = first\ndefaultResolvers.examples = examples\ndefaultResolvers.exclusiveMaximum = minimumValue\ndefaultResolvers.exclusiveMinimum = maximumValue\ndefaultResolvers.maximum = minimumValue\ndefaultResolvers.maxItems = minimumValue\ndefaultResolvers.maxLength = minimumValue\ndefaultResolvers.maxProperties = minimumValue\ndefaultResolvers.minimum = maximumValue\ndefaultResolvers.minItems = maximumValue\ndefaultResolvers.minLength = maximumValue\ndefaultResolvers.minProperties = maximumValue\ndefaultResolvers.propertyNames = schemaResolver\ndefaultResolvers.required = required\ndefaultResolvers.title = first\ndefaultResolvers.uniqueItems = uniqueItems\n\nfunction merger(rootSchema, options, totalSchemas) {\n  totalSchemas = totalSchemas || []\n  options = defaultsDeep(options, {\n    ignoreAdditionalProperties: false,\n    resolvers: defaultResolvers\n  })\n\n  function mergeSchemas(schemas, base, parents) {\n    schemas = cloneDeep(schemas.filter(notUndefined))\n    parents = parents || []\n    var merged = isPlainObject(base)\n      ? base\n      : {}\n\n    // return undefined, an empty schema\n    if (!schemas.length) {\n      return\n    }\n\n    if (schemas.some(isFalse)) {\n      return false\n    }\n\n    if (schemas.every(isTrue)) {\n      return true\n    }\n\n    // there are no false and we don't need the true ones as they accept everything\n    schemas = schemas.filter(isPlainObject)\n\n    var allKeys = allUniqueKeys(schemas)\n\n    if (contains(allKeys, 'allOf')) {\n      return merger({\n        allOf: schemas\n      }, options, totalSchemas)\n    }\n\n    var propertyKeys = allKeys.filter(isPropertyRelated)\n    pullAll(allKeys, propertyKeys)\n\n    var itemKeys = allKeys.filter(isItemsRelated)\n    pullAll(allKeys, itemKeys)\n\n    allKeys.forEach(function(key) {\n      var values = getValues(schemas, key)\n      var compacted = uniqWith(values.filter(notUndefined), compareProp(key))\n\n      // arrayprops like anyOf and oneOf must be merged first, as they contains schemas\n      // allOf is treated differently alltogether\n      if (compacted.length === 1 && contains(schemaArrays, key)) {\n        merged[key] = compacted[0].map(function(schema) {\n          return mergeSchemas([schema], schema)\n        })\n        // prop groups must always be resolved\n      } else if (compacted.length === 1 && !contains(schemaGroupProps, key) && !contains(schemaProps, key)) {\n        merged[key] = compacted[0]\n      } else {\n        var resolver = options.resolvers[key] || options.resolvers.defaultResolver\n\n        if (!resolver) {\n          throw new Error('No resolver found for key ' + key + '. You can provide a resolver for this keyword in the options, or provide a default resolver.')\n        }\n\n        var merger\n        // get custom merger for groups\n        if (contains(schemaGroupProps, key) || contains(schemaArrays, key)) {\n          merger = createRequiredSubMerger(mergeSchemas, key, parents)\n        } else {\n          merger = function(schemas) {\n            return mergeSchemas(schemas, null, parents.concat(key))\n          }\n        }\n\n        var calledWithArray = false\n        merged[key] = resolver(compacted, parents.concat(key), merger, options, function(unresolvedSchemas) {\n          calledWithArray = Array.isArray(unresolvedSchemas)\n          return addToAllOf(unresolvedSchemas)\n        })\n\n        if (merged[key] === undefined && !calledWithArray) {\n          throwIncompatible(compacted, parents.concat(key))\n        } else if (merged[key] === undefined) {\n          delete merged[key]\n        }\n      }\n    })\n\n    Object.assign(merged, callGroupResolver(propertyKeys, 'properties', schemas, mergeSchemas, options, parents))\n    Object.assign(merged, callGroupResolver(itemKeys, 'items', schemas, mergeSchemas, options, parents))\n\n    function addToAllOf(unresolvedSchemas) {\n      merged.allOf = mergeWithArray(merged.allOf, unresolvedSchemas)\n    }\n\n    return merged\n  }\n\n  var allSchemas = flattenDeep(getAllOf(rootSchema))\n  var merged = mergeSchemas(allSchemas, rootSchema)\n\n  return merged\n}\n\nmerger.options = {\n  resolvers: defaultResolvers\n}\n\nmodule.exports = merger\n"]},"metadata":{},"sourceType":"script"}